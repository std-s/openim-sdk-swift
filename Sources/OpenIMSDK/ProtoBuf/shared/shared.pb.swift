// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: shared.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum GroupStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// normal group chat
  case `default` // = 0

  /// the group chat has been disbanded
  case dismissed // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .default
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 2: self = .dismissed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .default: return 0
    case .dismissed: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [GroupStatus] = [
    .default,
    .dismissed,
  ]

}

public enum GroupJoinSource: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case ___ // = 0

  /// administrator invitation to join
  case admin // = 1

  /// invite to join
  case invitation // = 2

  /// search to join
  case search // = 3

  /// scan code to join
  case qrcode // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .___
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .___
    case 1: self = .admin
    case 2: self = .invitation
    case 3: self = .search
    case 4: self = .qrcode
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .___: return 0
    case .admin: return 1
    case .invitation: return 2
    case .search: return 3
    case .qrcode: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [GroupJoinSource] = [
    .___,
    .admin,
    .invitation,
    .search,
    .qrcode,
  ]

}

public enum GroupNeedVerification: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// application requires consent, and invitation is direct entry.
  case applyNeedVerificationInviteDirectly // = 0

  /// everyone entering the group needs to be verified, except for those invited by the group owner or administrator.
  case allNeedVerification // = 1

  /// direct access to group chat.
  case directAccess // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .applyNeedVerificationInviteDirectly
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .applyNeedVerificationInviteDirectly
    case 1: self = .allNeedVerification
    case 2: self = .directAccess
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .applyNeedVerificationInviteDirectly: return 0
    case .allNeedVerification: return 1
    case .directAccess: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [GroupNeedVerification] = [
    .applyNeedVerificationInviteDirectly,
    .allNeedVerification,
    .directAccess,
  ]

}

public enum GroupLookMemberInfo: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// do not allow access to member information via the group
  case prohibitGroupLookMemberInfo // = 0

  /// allow access to member information via the group
  case allowGroupLookMemberInfo // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .prohibitGroupLookMemberInfo
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .prohibitGroupLookMemberInfo
    case 1: self = .allowGroupLookMemberInfo
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .prohibitGroupLookMemberInfo: return 0
    case .allowGroupLookMemberInfo: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [GroupLookMemberInfo] = [
    .prohibitGroupLookMemberInfo,
    .allowGroupLookMemberInfo,
  ]

}

public enum GroupApplyMemberFriend: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// do not allow group members to add friends directly
  case prohibitGroupApplyMemberFriend // = 0

  /// allow group members to add friends directly
  case allowGroupApplyMemberFriend // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .prohibitGroupApplyMemberFriend
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .prohibitGroupApplyMemberFriend
    case 1: self = .allowGroupApplyMemberFriend
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .prohibitGroupApplyMemberFriend: return 0
    case .allowGroupApplyMemberFriend: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [GroupApplyMemberFriend] = [
    .prohibitGroupApplyMemberFriend,
    .allowGroupApplyMemberFriend,
  ]

}

/// IM User information
public struct IMUser: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @user_id
  public var userID: String = String()

  /// @user_nickname
  public var nickname: String = String()

  /// @user_face_url
  public var faceURL: String = String()

  /// @user_ex
  public var ex: String = String()

  /// @user_create_time
  public var createTime: Int64 = 0

  /// @user_global_recv_msg_opt
  public var globalRecvMsgOpt: GlobalRecvMsgOpt = .normal

  /// @user_attached
  public var attached: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CommandInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var type: Int32 = 0

  public var createTime: Int64 = 0

  public var uuid: String = String()

  public var value: String = String()

  public var ex: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// IM Friend information
public struct IMFriend: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Currently logged-in user ID
  public var ownerUserID: String = String()

  /// Friend user ID
  public var friendUserID: String = String()

  /// Friend remark
  public var remark: String = String()

  /// Friend add time
  public var createTime: Int64 = 0

  /// Friend add source
  public var addSource: Int32 = 0

  /// Operator user ID
  public var operatorUserID: String = String()

  /// Friend nickname
  public var nickname: String = String()

  /// Friend avatar URL
  public var faceURL: String = String()

  /// Friend extension field
  public var ex: String = String()

  /// SDK internal extension field, not currently used
  public var attachedInfo: String = String()

  /// Whether the friend is pinned
  public var isPinned: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IMBlack: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Currently logged-in user ID
  public var ownerUserID: String = String()

  /// Blocked user ID
  public var blockUserID: String = String()

  /// Blocked user nickname
  public var nickname: String = String()

  /// Blocked user avatar URL
  public var faceURL: String = String()

  /// Block time
  public var createTime: Int64 = 0

  /// Block source
  public var addSource: Int32 = 0

  /// Operator user ID
  public var operatorUserID: String = String()

  /// Block extension field
  public var ex: String = String()

  /// SDK internal extension field, not currently used
  public var attached: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IMFriendApplication: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Requester user ID
  public var fromUserID: String = String()

  /// Requester nickname
  public var fromNickname: String = String()

  /// Requester avatar URL
  public var fromFaceURL: String = String()

  /// Receiver user ID
  public var toUserID: String = String()

  /// Receiver nickname
  public var toNickname: String = String()

  /// Receiver avatar URL
  public var toFaceURL: String = String()

  /// Request handle result
  public var handleResult: Int32 = 0

  /// Request message
  public var reqMsg: String = String()

  /// Request create time
  public var createTime: Int64 = 0

  /// Request handler user ID
  public var handlerUserID: String = String()

  /// Request handle message
  public var handleMsg: String = String()

  /// Request handle time
  public var handleTime: Int64 = 0

  /// Request extension field
  public var ex: String = String()

  /// SDK internal extension field, not currently used
  public var attached: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IMGroup: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @group_id
  public var groupID: String {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  /// @group_name
  public var groupName: String {
    get {return _storage._groupName}
    set {_uniqueStorage()._groupName = newValue}
  }

  /// @group_notification
  public var notification: String {
    get {return _storage._notification}
    set {_uniqueStorage()._notification = newValue}
  }

  /// @group_introduction
  public var introduction: String {
    get {return _storage._introduction}
    set {_uniqueStorage()._introduction = newValue}
  }

  /// @group_face_url
  public var faceURL: String {
    get {return _storage._faceURL}
    set {_uniqueStorage()._faceURL = newValue}
  }

  /// @group_owner_user_id
  public var ownerUserID: String {
    get {return _storage._ownerUserID}
    set {_uniqueStorage()._ownerUserID = newValue}
  }

  /// @group_create_time
  public var createTime: Int64 {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  /// @group_member_count
  public var memberCount: Int64 {
    get {return _storage._memberCount}
    set {_uniqueStorage()._memberCount = newValue}
  }

  /// @group_ex
  public var ex: String {
    get {return _storage._ex}
    set {_uniqueStorage()._ex = newValue}
  }

  /// @group_status
  public var status: GroupStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// @group_creator_user_id
  public var creatorUserID: String {
    get {return _storage._creatorUserID}
    set {_uniqueStorage()._creatorUserID = newValue}
  }

  /// @group_need_verification
  public var needVerification: GroupNeedVerification {
    get {return _storage._needVerification}
    set {_uniqueStorage()._needVerification = newValue}
  }

  /// @group_look_member_info
  public var lookMemberInfo: GroupLookMemberInfo {
    get {return _storage._lookMemberInfo}
    set {_uniqueStorage()._lookMemberInfo = newValue}
  }

  /// @group_apply_member_friend
  public var applyMemberFriend: GroupApplyMemberFriend {
    get {return _storage._applyMemberFriend}
    set {_uniqueStorage()._applyMemberFriend = newValue}
  }

  /// @group_notification_update_time
  public var notificationUpdateTime: Int64 {
    get {return _storage._notificationUpdateTime}
    set {_uniqueStorage()._notificationUpdateTime = newValue}
  }

  /// @group_notification_user_id
  public var notificationUserID: String {
    get {return _storage._notificationUserID}
    set {_uniqueStorage()._notificationUserID = newValue}
  }

  /// @group_attached_info
  public var attachedInfo: String {
    get {return _storage._attachedInfo}
    set {_uniqueStorage()._attachedInfo = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct IMGroupMember: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @group_id
  public var groupID: String = String()

  /// @group_member_user_id
  public var userID: String = String()

  /// @group_member_nickname
  public var nickname: String = String()

  /// @group_member_face_url
  public var faceURL: String = String()

  /// @group_member_role
  public var roleLevel: Int32 = 0

  /// @group_member_join_time
  public var joinTime: Int64 = 0

  /// @group_member_join_source
  public var joinSource: GroupJoinSource = .___

  /// @group_member_inviter_user_id
  public var inviterUserID: String = String()

  /// @group_member_mute_end_time
  public var muteEndTime: Int64 = 0

  /// @group_member_operator_user_id
  public var operatorUserID: String = String()

  /// @group_member_ex
  public var ex: String = String()

  /// @group_member_attached_info
  public var attachedInfo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IMGroupApplication: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @group_id
  public var groupID: String {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  /// @group_name
  public var groupName: String {
    get {return _storage._groupName}
    set {_uniqueStorage()._groupName = newValue}
  }

  /// @group_notification
  public var notification: String {
    get {return _storage._notification}
    set {_uniqueStorage()._notification = newValue}
  }

  /// @group_introduction
  public var introduction: String {
    get {return _storage._introduction}
    set {_uniqueStorage()._introduction = newValue}
  }

  /// @group_face_url
  public var groupFaceURL: String {
    get {return _storage._groupFaceURL}
    set {_uniqueStorage()._groupFaceURL = newValue}
  }

  /// @group_create_time
  public var createTime: Int64 {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  /// @group_status
  public var status: Int32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// @group_creator_user_id
  public var creatorUserID: String {
    get {return _storage._creatorUserID}
    set {_uniqueStorage()._creatorUserID = newValue}
  }

  /// @group_owner_user_id
  public var ownerUserID: String {
    get {return _storage._ownerUserID}
    set {_uniqueStorage()._ownerUserID = newValue}
  }

  /// @group_member_count
  public var memberCount: Int32 {
    get {return _storage._memberCount}
    set {_uniqueStorage()._memberCount = newValue}
  }

  /// @user_id
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// @user_nickname
  public var nickname: String {
    get {return _storage._nickname}
    set {_uniqueStorage()._nickname = newValue}
  }

  /// @user_face_url
  public var userFaceURL: String {
    get {return _storage._userFaceURL}
    set {_uniqueStorage()._userFaceURL = newValue}
  }

  /// group application handle result
  public var handleResult: Int32 {
    get {return _storage._handleResult}
    set {_uniqueStorage()._handleResult = newValue}
  }

  /// group application request message
  public var reqMsg: String {
    get {return _storage._reqMsg}
    set {_uniqueStorage()._reqMsg = newValue}
  }

  /// group application handle message
  public var handledMsg: String {
    get {return _storage._handledMsg}
    set {_uniqueStorage()._handledMsg = newValue}
  }

  /// group application create time
  public var reqTime: Int64 {
    get {return _storage._reqTime}
    set {_uniqueStorage()._reqTime = newValue}
  }

  /// group application handle user id
  public var handleUserID: String {
    get {return _storage._handleUserID}
    set {_uniqueStorage()._handleUserID = newValue}
  }

  /// group application handle time
  public var handledTime: Int64 {
    get {return _storage._handledTime}
    set {_uniqueStorage()._handledTime = newValue}
  }

  /// group application extension field
  public var ex: String {
    get {return _storage._ex}
    set {_uniqueStorage()._ex = newValue}
  }

  /// @group_member_attached_info
  public var attachedInfo: String {
    get {return _storage._attachedInfo}
    set {_uniqueStorage()._attachedInfo = newValue}
  }

  /// @group_member_join_source
  public var joinSource: GroupJoinSource {
    get {return _storage._joinSource}
    set {_uniqueStorage()._joinSource = newValue}
  }

  /// @group_member_inviter_user_id
  public var inviterUserID: String {
    get {return _storage._inviterUserID}
    set {_uniqueStorage()._inviterUserID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct IMConversation: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String {
    get {return _storage._conversationID}
    set {_uniqueStorage()._conversationID = newValue}
  }

  public var conversationType: SessionType {
    get {return _storage._conversationType}
    set {_uniqueStorage()._conversationType = newValue}
  }

  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  public var groupID: String {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  public var showName: String {
    get {return _storage._showName}
    set {_uniqueStorage()._showName = newValue}
  }

  public var faceURL: String {
    get {return _storage._faceURL}
    set {_uniqueStorage()._faceURL = newValue}
  }

  public var recvMsgOpt: ConvRecvMsgOpt {
    get {return _storage._recvMsgOpt}
    set {_uniqueStorage()._recvMsgOpt = newValue}
  }

  public var unreadCount: Int32 {
    get {return _storage._unreadCount}
    set {_uniqueStorage()._unreadCount = newValue}
  }

  public var groupAtType: ConvGroupAtType {
    get {return _storage._groupAtType}
    set {_uniqueStorage()._groupAtType = newValue}
  }

  public var latestMsg: IMMessage {
    get {return _storage._latestMsg ?? IMMessage()}
    set {_uniqueStorage()._latestMsg = newValue}
  }
  /// Returns true if `latestMsg` has been explicitly set.
  public var hasLatestMsg: Bool {return _storage._latestMsg != nil}
  /// Clears the value of `latestMsg`. Subsequent reads from it will return its default value.
  public mutating func clearLatestMsg() {_uniqueStorage()._latestMsg = nil}

  public var latestMsgSendTime: Int64 {
    get {return _storage._latestMsgSendTime}
    set {_uniqueStorage()._latestMsgSendTime = newValue}
  }

  public var draftText: String {
    get {return _storage._draftText}
    set {_uniqueStorage()._draftText = newValue}
  }

  public var draftTextTime: Int64 {
    get {return _storage._draftTextTime}
    set {_uniqueStorage()._draftTextTime = newValue}
  }

  public var isPinned: Bool {
    get {return _storage._isPinned}
    set {_uniqueStorage()._isPinned = newValue}
  }

  public var isPrivateChat: Bool {
    get {return _storage._isPrivateChat}
    set {_uniqueStorage()._isPrivateChat = newValue}
  }

  public var burnDuration: Int32 {
    get {return _storage._burnDuration}
    set {_uniqueStorage()._burnDuration = newValue}
  }

  public var ex: String {
    get {return _storage._ex}
    set {_uniqueStorage()._ex = newValue}
  }

  public var msgDestructTime: Int64 {
    get {return _storage._msgDestructTime}
    set {_uniqueStorage()._msgDestructTime = newValue}
  }

  public var isMsgDestruct: Bool {
    get {return _storage._isMsgDestruct}
    set {_uniqueStorage()._isMsgDestruct = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct AtInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var atUserID: String = String()

  public var groupNickname: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ImageInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var width: Int32 = 0

  public var height: Int32 = 0

  public var type: String = String()

  public var size: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PictureBaseInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: String = String()

  public var type: String = String()

  public var size: Int64 = 0

  public var width: Int32 = 0

  public var height: Int32 = 0

  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SoundBaseInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: String = String()

  public var soundPath: String = String()

  public var sourceURL: String = String()

  public var dataSize: Int64 = 0

  public var duration: Int64 = 0

  public var soundType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct VideoBaseInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var videoPath: String = String()

  public var videoUuid: String = String()

  public var videoURL: String = String()

  public var videoType: String = String()

  public var videoSize: Int64 = 0

  public var duration: Int64 = 0

  public var snapshotPath: String = String()

  public var snapshotUuid: String = String()

  public var snapshotSize: Int64 = 0

  public var snapshotURL: String = String()

  public var snapshotWidth: Int32 = 0

  public var snapshotHeight: Int32 = 0

  public var snapshotType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FileBaseInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filePath: String = String()

  public var uuid: String = String()

  public var sourceURL: String = String()

  public var fileName: String = String()

  public var fileSize: Int64 = 0

  public var fileType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TextElem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CardElem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var nickname: String = String()

  public var faceURL: String = String()

  public var ex: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PictureElem: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sourcePath: String {
    get {return _storage._sourcePath}
    set {_uniqueStorage()._sourcePath = newValue}
  }

  public var sourcePicture: PictureBaseInfo {
    get {return _storage._sourcePicture ?? PictureBaseInfo()}
    set {_uniqueStorage()._sourcePicture = newValue}
  }
  /// Returns true if `sourcePicture` has been explicitly set.
  public var hasSourcePicture: Bool {return _storage._sourcePicture != nil}
  /// Clears the value of `sourcePicture`. Subsequent reads from it will return its default value.
  public mutating func clearSourcePicture() {_uniqueStorage()._sourcePicture = nil}

  public var bigPicture: PictureBaseInfo {
    get {return _storage._bigPicture ?? PictureBaseInfo()}
    set {_uniqueStorage()._bigPicture = newValue}
  }
  /// Returns true if `bigPicture` has been explicitly set.
  public var hasBigPicture: Bool {return _storage._bigPicture != nil}
  /// Clears the value of `bigPicture`. Subsequent reads from it will return its default value.
  public mutating func clearBigPicture() {_uniqueStorage()._bigPicture = nil}

  public var snapshotPicture: PictureBaseInfo {
    get {return _storage._snapshotPicture ?? PictureBaseInfo()}
    set {_uniqueStorage()._snapshotPicture = newValue}
  }
  /// Returns true if `snapshotPicture` has been explicitly set.
  public var hasSnapshotPicture: Bool {return _storage._snapshotPicture != nil}
  /// Clears the value of `snapshotPicture`. Subsequent reads from it will return its default value.
  public mutating func clearSnapshotPicture() {_uniqueStorage()._snapshotPicture = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct SoundElem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: String = String()

  public var soundPath: String = String()

  public var sourceURL: String = String()

  public var dataSize: Int64 = 0

  public var duration: Int64 = 0

  public var soundType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct VideoElem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var videoPath: String = String()

  public var videoUuid: String = String()

  public var videoURL: String = String()

  public var videoType: String = String()

  public var videoSize: Int64 = 0

  public var duration: Int64 = 0

  public var snapshotPath: String = String()

  public var snapshotUuid: String = String()

  public var snapshotSize: Int64 = 0

  public var snapshotURL: String = String()

  public var snapshotWidth: Int32 = 0

  public var snapshotHeight: Int32 = 0

  public var snapshotType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FileElem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filePath: String = String()

  public var uuid: String = String()

  public var sourceURL: String = String()

  public var fileName: String = String()

  public var fileSize: Int64 = 0

  public var fileType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MessageEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var offset: Int32 = 0

  public var length: Int32 = 0

  public var url: String = String()

  public var ex: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MergeElem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var abstractList: [String] = []

  public var multiMessage: [IMMessage] = []

  public var messageEntityList: [MessageEntity] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct AtTextElem: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String {
    get {return _storage._text}
    set {_uniqueStorage()._text = newValue}
  }

  public var atUserList: [String] {
    get {return _storage._atUserList}
    set {_uniqueStorage()._atUserList = newValue}
  }

  public var atUsersInfo: [AtInfo] {
    get {return _storage._atUsersInfo}
    set {_uniqueStorage()._atUsersInfo = newValue}
  }

  public var quoteMessage: IMMessage {
    get {return _storage._quoteMessage ?? IMMessage()}
    set {_uniqueStorage()._quoteMessage = newValue}
  }
  /// Returns true if `quoteMessage` has been explicitly set.
  public var hasQuoteMessage: Bool {return _storage._quoteMessage != nil}
  /// Clears the value of `quoteMessage`. Subsequent reads from it will return its default value.
  public mutating func clearQuoteMessage() {_uniqueStorage()._quoteMessage = nil}

  public var isAtSelf: Bool {
    get {return _storage._isAtSelf}
    set {_uniqueStorage()._isAtSelf = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct FaceElem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var index: Int32 = 0

  public var data: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct LocationElem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var description_p: String = String()

  public var longitude: Double = 0

  public var latitude: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CustomElem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: String = String()

  public var description_p: String = String()

  public var `extension`: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct QuoteElem: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String {
    get {return _storage._text}
    set {_uniqueStorage()._text = newValue}
  }

  public var quoteMessage: IMMessage {
    get {return _storage._quoteMessage ?? IMMessage()}
    set {_uniqueStorage()._quoteMessage = newValue}
  }
  /// Returns true if `quoteMessage` has been explicitly set.
  public var hasQuoteMessage: Bool {return _storage._quoteMessage != nil}
  /// Clears the value of `quoteMessage`. Subsequent reads from it will return its default value.
  public mutating func clearQuoteMessage() {_uniqueStorage()._quoteMessage = nil}

  public var messageEntityList: [MessageEntity] {
    get {return _storage._messageEntityList}
    set {_uniqueStorage()._messageEntityList = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct AdvancedTextElem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var messageEntityList: [MessageEntity] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TypingElem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var msgTips: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct StreamElem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var content: String = String()

  public var packets: [String] = []

  public var end: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UploadProgress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var total: Int64 = 0

  public var save: Int64 = 0

  public var current: Int64 = 0

  public var uploadID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct AttachedInfoElem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isPrivateChat: Bool = false

  public var burnDuration: Int32 = 0

  public var hasReadTime_p: Int64 = 0

  public var progress: UploadProgress {
    get {return _progress ?? UploadProgress()}
    set {_progress = newValue}
  }
  /// Returns true if `progress` has been explicitly set.
  public var hasProgress: Bool {return self._progress != nil}
  /// Clears the value of `progress`. Subsequent reads from it will return its default value.
  public mutating func clearProgress() {self._progress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _progress: UploadProgress? = nil
}

///////////////////////group/////////////////////
///
///	OnGroupCreated()
public struct GroupCreatedTips: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _storage._group ?? IMGroup()}
    set {_uniqueStorage()._group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return _storage._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {_uniqueStorage()._group = nil}

  public var opUser: IMGroupMember {
    get {return _storage._opUser ?? IMGroupMember()}
    set {_uniqueStorage()._opUser = newValue}
  }
  /// Returns true if `opUser` has been explicitly set.
  public var hasOpUser: Bool {return _storage._opUser != nil}
  /// Clears the value of `opUser`. Subsequent reads from it will return its default value.
  public mutating func clearOpUser() {_uniqueStorage()._opUser = nil}

  public var memberList: [IMGroupMember] {
    get {return _storage._memberList}
    set {_uniqueStorage()._memberList = newValue}
  }

  public var operationTime: Int64 {
    get {return _storage._operationTime}
    set {_uniqueStorage()._operationTime = newValue}
  }

  public var groupOwnerUser: IMGroupMember {
    get {return _storage._groupOwnerUser ?? IMGroupMember()}
    set {_uniqueStorage()._groupOwnerUser = newValue}
  }
  /// Returns true if `groupOwnerUser` has been explicitly set.
  public var hasGroupOwnerUser: Bool {return _storage._groupOwnerUser != nil}
  /// Clears the value of `groupOwnerUser`. Subsequent reads from it will return its default value.
  public mutating func clearGroupOwnerUser() {_uniqueStorage()._groupOwnerUser = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
///	OnGroupInfoSet()
///message GroupInfoSetTips {
///  shared.IMGroupMember opUser = 1; //who do this
///  int64 muteTime = 2;
///  shared.IMGroup group = 3;
///}
///
///message GroupInfoSetNameTips {
///  shared.IMGroupMember opUser = 1; //who do this
///  shared.IMGroup group = 2;
///}
///
///message GroupInfoSetAnnouncementTips {
///  shared.IMGroupMember opUser = 1; //who do this
///  shared.IMGroup group = 2;
///}
///
///	OnJoinGroupApplication()
///message JoinGroupApplicationTips {
///  shared.IMGroup group = 1;
///  shared.IMUser applicant = 2;
///  string reqMsg = 3;
///}
///
///	OnQuitGroup()
///Actively leave the group
public struct MemberQuitTips: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _group ?? IMGroup()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  public var quitUser: IMGroupMember {
    get {return _quitUser ?? IMGroupMember()}
    set {_quitUser = newValue}
  }
  /// Returns true if `quitUser` has been explicitly set.
  public var hasQuitUser: Bool {return self._quitUser != nil}
  /// Clears the value of `quitUser`. Subsequent reads from it will return its default value.
  public mutating func clearQuitUser() {self._quitUser = nil}

  public var operationTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _group: IMGroup? = nil
  fileprivate var _quitUser: IMGroupMember? = nil
}

///
///	OnApplicationGroupAccepted()
///message GroupApplicationAcceptedTips {
///  shared.IMGroup group = 1;
///  shared.IMGroupMember opUser = 2;
///  string handleMsg = 4;
///  int32 receiverAs = 5; // admin(==1) or applicant(==0)
///}
///
///	OnApplicationGroupRejected()
///message GroupApplicationRejectedTips {
///  shared.IMGroup group = 1;
///  shared.IMGroupMember opUser = 2;
///  string handleMsg = 4;
///  int32 receiverAs = 5; // admin(==1) or applicant(==0)
///}
///
///	OnTransferGroupOwner()
public struct GroupOwnerTransferredTips: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _storage._group ?? IMGroup()}
    set {_uniqueStorage()._group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return _storage._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {_uniqueStorage()._group = nil}

  public var opUser: IMGroupMember {
    get {return _storage._opUser ?? IMGroupMember()}
    set {_uniqueStorage()._opUser = newValue}
  }
  /// Returns true if `opUser` has been explicitly set.
  public var hasOpUser: Bool {return _storage._opUser != nil}
  /// Clears the value of `opUser`. Subsequent reads from it will return its default value.
  public mutating func clearOpUser() {_uniqueStorage()._opUser = nil}

  public var newGroupOwner: IMGroupMember {
    get {return _storage._newGroupOwner ?? IMGroupMember()}
    set {_uniqueStorage()._newGroupOwner = newValue}
  }
  /// Returns true if `newGroupOwner` has been explicitly set.
  public var hasNewGroupOwner: Bool {return _storage._newGroupOwner != nil}
  /// Clears the value of `newGroupOwner`. Subsequent reads from it will return its default value.
  public mutating func clearNewGroupOwner() {_uniqueStorage()._newGroupOwner = nil}

  public var oldGroupOwner: String {
    get {return _storage._oldGroupOwner}
    set {_uniqueStorage()._oldGroupOwner = newValue}
  }

  public var operationTime: Int64 {
    get {return _storage._operationTime}
    set {_uniqueStorage()._operationTime = newValue}
  }

  public var oldGroupOwnerInfo: IMGroupMember {
    get {return _storage._oldGroupOwnerInfo ?? IMGroupMember()}
    set {_uniqueStorage()._oldGroupOwnerInfo = newValue}
  }
  /// Returns true if `oldGroupOwnerInfo` has been explicitly set.
  public var hasOldGroupOwnerInfo: Bool {return _storage._oldGroupOwnerInfo != nil}
  /// Clears the value of `oldGroupOwnerInfo`. Subsequent reads from it will return its default value.
  public mutating func clearOldGroupOwnerInfo() {_uniqueStorage()._oldGroupOwnerInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
///	OnMemberKicked()
public struct MemberKickedTips: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _group ?? IMGroup()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  public var opUser: IMGroupMember {
    get {return _opUser ?? IMGroupMember()}
    set {_opUser = newValue}
  }
  /// Returns true if `opUser` has been explicitly set.
  public var hasOpUser: Bool {return self._opUser != nil}
  /// Clears the value of `opUser`. Subsequent reads from it will return its default value.
  public mutating func clearOpUser() {self._opUser = nil}

  public var kickedUserList: [IMGroupMember] = []

  public var operationTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _group: IMGroup? = nil
  fileprivate var _opUser: IMGroupMember? = nil
}

///
///	OnMemberInvited()
public struct MemberInvitedTips: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _storage._group ?? IMGroup()}
    set {_uniqueStorage()._group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return _storage._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {_uniqueStorage()._group = nil}

  public var opUser: IMGroupMember {
    get {return _storage._opUser ?? IMGroupMember()}
    set {_uniqueStorage()._opUser = newValue}
  }
  /// Returns true if `opUser` has been explicitly set.
  public var hasOpUser: Bool {return _storage._opUser != nil}
  /// Clears the value of `opUser`. Subsequent reads from it will return its default value.
  public mutating func clearOpUser() {_uniqueStorage()._opUser = nil}

  public var invitedUserList: [IMGroupMember] {
    get {return _storage._invitedUserList}
    set {_uniqueStorage()._invitedUserList = newValue}
  }

  public var operationTime: Int64 {
    get {return _storage._operationTime}
    set {_uniqueStorage()._operationTime = newValue}
  }

  public var inviterUser: IMGroupMember {
    get {return _storage._inviterUser ?? IMGroupMember()}
    set {_uniqueStorage()._inviterUser = newValue}
  }
  /// Returns true if `inviterUser` has been explicitly set.
  public var hasInviterUser: Bool {return _storage._inviterUser != nil}
  /// Clears the value of `inviterUser`. Subsequent reads from it will return its default value.
  public mutating func clearInviterUser() {_uniqueStorage()._inviterUser = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
///Actively join the group
public struct MemberEnterTips: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _group ?? IMGroup()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  public var entrantUser: IMGroupMember {
    get {return _entrantUser ?? IMGroupMember()}
    set {_entrantUser = newValue}
  }
  /// Returns true if `entrantUser` has been explicitly set.
  public var hasEntrantUser: Bool {return self._entrantUser != nil}
  /// Clears the value of `entrantUser`. Subsequent reads from it will return its default value.
  public mutating func clearEntrantUser() {self._entrantUser = nil}

  public var operationTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _group: IMGroup? = nil
  fileprivate var _entrantUser: IMGroupMember? = nil
}

public struct GroupDismissedTips: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _group ?? IMGroup()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  public var opUser: IMGroupMember {
    get {return _opUser ?? IMGroupMember()}
    set {_opUser = newValue}
  }
  /// Returns true if `opUser` has been explicitly set.
  public var hasOpUser: Bool {return self._opUser != nil}
  /// Clears the value of `opUser`. Subsequent reads from it will return its default value.
  public mutating func clearOpUser() {self._opUser = nil}

  public var operationTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _group: IMGroup? = nil
  fileprivate var _opUser: IMGroupMember? = nil
}

public struct GroupMemberMutedTips: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _storage._group ?? IMGroup()}
    set {_uniqueStorage()._group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return _storage._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {_uniqueStorage()._group = nil}

  public var opUser: IMGroupMember {
    get {return _storage._opUser ?? IMGroupMember()}
    set {_uniqueStorage()._opUser = newValue}
  }
  /// Returns true if `opUser` has been explicitly set.
  public var hasOpUser: Bool {return _storage._opUser != nil}
  /// Clears the value of `opUser`. Subsequent reads from it will return its default value.
  public mutating func clearOpUser() {_uniqueStorage()._opUser = nil}

  public var operationTime: Int64 {
    get {return _storage._operationTime}
    set {_uniqueStorage()._operationTime = newValue}
  }

  public var mutedUser: IMGroupMember {
    get {return _storage._mutedUser ?? IMGroupMember()}
    set {_uniqueStorage()._mutedUser = newValue}
  }
  /// Returns true if `mutedUser` has been explicitly set.
  public var hasMutedUser: Bool {return _storage._mutedUser != nil}
  /// Clears the value of `mutedUser`. Subsequent reads from it will return its default value.
  public mutating func clearMutedUser() {_uniqueStorage()._mutedUser = nil}

  public var mutedSeconds: UInt32 {
    get {return _storage._mutedSeconds}
    set {_uniqueStorage()._mutedSeconds = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct GroupMemberCancelMutedTips: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _storage._group ?? IMGroup()}
    set {_uniqueStorage()._group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return _storage._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {_uniqueStorage()._group = nil}

  public var opUser: IMGroupMember {
    get {return _storage._opUser ?? IMGroupMember()}
    set {_uniqueStorage()._opUser = newValue}
  }
  /// Returns true if `opUser` has been explicitly set.
  public var hasOpUser: Bool {return _storage._opUser != nil}
  /// Clears the value of `opUser`. Subsequent reads from it will return its default value.
  public mutating func clearOpUser() {_uniqueStorage()._opUser = nil}

  public var operationTime: Int64 {
    get {return _storage._operationTime}
    set {_uniqueStorage()._operationTime = newValue}
  }

  public var mutedUser: IMGroupMember {
    get {return _storage._mutedUser ?? IMGroupMember()}
    set {_uniqueStorage()._mutedUser = newValue}
  }
  /// Returns true if `mutedUser` has been explicitly set.
  public var hasMutedUser: Bool {return _storage._mutedUser != nil}
  /// Clears the value of `mutedUser`. Subsequent reads from it will return its default value.
  public mutating func clearMutedUser() {_uniqueStorage()._mutedUser = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct GroupMutedTips: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _group ?? IMGroup()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  public var opUser: IMGroupMember {
    get {return _opUser ?? IMGroupMember()}
    set {_opUser = newValue}
  }
  /// Returns true if `opUser` has been explicitly set.
  public var hasOpUser: Bool {return self._opUser != nil}
  /// Clears the value of `opUser`. Subsequent reads from it will return its default value.
  public mutating func clearOpUser() {self._opUser = nil}

  public var operationTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _group: IMGroup? = nil
  fileprivate var _opUser: IMGroupMember? = nil
}

public struct GroupCancelMutedTips: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _group ?? IMGroup()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  public var opUser: IMGroupMember {
    get {return _opUser ?? IMGroupMember()}
    set {_opUser = newValue}
  }
  /// Returns true if `opUser` has been explicitly set.
  public var hasOpUser: Bool {return self._opUser != nil}
  /// Clears the value of `opUser`. Subsequent reads from it will return its default value.
  public mutating func clearOpUser() {self._opUser = nil}

  public var operationTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _group: IMGroup? = nil
  fileprivate var _opUser: IMGroupMember? = nil
}

///
///message GroupMemberInfoSetTips {
///  shared.IMGroup group = 1;
///  shared.IMGroupMember opUser = 2;
///  int64 operationTime = 3;
///  shared.IMGroupMember changedUser = 4;
///}
///
///////////////////////friend/////////////////////
///
///message FriendApplication {
///  int64 addTime = 1;
///  string addSource = 2;
///  string addWording = 3;
///}
public struct FromToUserID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fromUserID: String = String()

  public var toUserID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
///FromUserID apply to add ToUserID
///message FriendApplicationTips {
///  FromToUserID fromToUserID = 1;
///}
///
///FromUserID accept or reject ToUserID
public struct FriendApplicationApprovedTips: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fromToUserID: FromToUserID {
    get {return _fromToUserID ?? FromToUserID()}
    set {_fromToUserID = newValue}
  }
  /// Returns true if `fromToUserID` has been explicitly set.
  public var hasFromToUserID: Bool {return self._fromToUserID != nil}
  /// Clears the value of `fromToUserID`. Subsequent reads from it will return its default value.
  public mutating func clearFromToUserID() {self._fromToUserID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fromToUserID: FromToUserID? = nil
}

public struct RevokedTips: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var revokerID: String = String()

  public var revokerRole: Int32 = 0

  public var clientMsgID: String = String()

  public var revokerNickname: String = String()

  public var revokeTime: Int64 = 0

  public var sourceMessageSendTime: Int64 = 0

  public var sourceMessageSendID: String = String()

  public var sourceMessageSenderNickname: String = String()

  public var sessionType: Int32 = 0

  public var seq: Int64 = 0

  public var ex: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ConversationPrivateChatTips: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var recvID: String = String()

  public var sendID: String = String()

  public var isPrivate: Bool = false

  public var conversationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BusinessTips: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var data: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IMMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clientMsgID: String {
    get {return _storage._clientMsgID}
    set {_uniqueStorage()._clientMsgID = newValue}
  }

  public var serverMsgID: String {
    get {return _storage._serverMsgID}
    set {_uniqueStorage()._serverMsgID = newValue}
  }

  public var createTime: Int64 {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  public var sendTime: Int64 {
    get {return _storage._sendTime}
    set {_uniqueStorage()._sendTime = newValue}
  }

  public var sessionType: SessionType {
    get {return _storage._sessionType}
    set {_uniqueStorage()._sessionType = newValue}
  }

  public var sendID: String {
    get {return _storage._sendID}
    set {_uniqueStorage()._sendID = newValue}
  }

  public var recvID: String {
    get {return _storage._recvID}
    set {_uniqueStorage()._recvID = newValue}
  }

  public var msgFrom: MsgFrom {
    get {return _storage._msgFrom}
    set {_uniqueStorage()._msgFrom = newValue}
  }

  public var contentType: ContentType {
    get {return _storage._contentType}
    set {_uniqueStorage()._contentType = newValue}
  }

  public var senderPlatformID: Platform {
    get {return _storage._senderPlatformID}
    set {_uniqueStorage()._senderPlatformID = newValue}
  }

  public var senderNickname: String {
    get {return _storage._senderNickname}
    set {_uniqueStorage()._senderNickname = newValue}
  }

  public var senderFaceURL: String {
    get {return _storage._senderFaceURL}
    set {_uniqueStorage()._senderFaceURL = newValue}
  }

  public var groupID: String {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  public var seq: Int64 {
    get {return _storage._seq}
    set {_uniqueStorage()._seq = newValue}
  }

  public var isRead: Bool {
    get {return _storage._isRead}
    set {_uniqueStorage()._isRead = newValue}
  }

  public var status: MsgStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var offlinePush: OfflinePushInfo {
    get {return _storage._offlinePush ?? OfflinePushInfo()}
    set {_uniqueStorage()._offlinePush = newValue}
  }
  /// Returns true if `offlinePush` has been explicitly set.
  public var hasOfflinePush: Bool {return _storage._offlinePush != nil}
  /// Clears the value of `offlinePush`. Subsequent reads from it will return its default value.
  public mutating func clearOfflinePush() {_uniqueStorage()._offlinePush = nil}

  public var ex: String {
    get {return _storage._ex}
    set {_uniqueStorage()._ex = newValue}
  }

  public var localEx: String {
    get {return _storage._localEx}
    set {_uniqueStorage()._localEx = newValue}
  }

  public var attachedInfoElem: AttachedInfoElem {
    get {return _storage._attachedInfoElem ?? AttachedInfoElem()}
    set {_uniqueStorage()._attachedInfoElem = newValue}
  }
  /// Returns true if `attachedInfoElem` has been explicitly set.
  public var hasAttachedInfoElem: Bool {return _storage._attachedInfoElem != nil}
  /// Clears the value of `attachedInfoElem`. Subsequent reads from it will return its default value.
  public mutating func clearAttachedInfoElem() {_uniqueStorage()._attachedInfoElem = nil}

  public var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  public var textElem: TextElem {
    get {
      if case .textElem(let v)? = _storage._content {return v}
      return TextElem()
    }
    set {_uniqueStorage()._content = .textElem(newValue)}
  }

  public var cardElem: CardElem {
    get {
      if case .cardElem(let v)? = _storage._content {return v}
      return CardElem()
    }
    set {_uniqueStorage()._content = .cardElem(newValue)}
  }

  public var pictureElem: PictureElem {
    get {
      if case .pictureElem(let v)? = _storage._content {return v}
      return PictureElem()
    }
    set {_uniqueStorage()._content = .pictureElem(newValue)}
  }

  public var soundElem: SoundElem {
    get {
      if case .soundElem(let v)? = _storage._content {return v}
      return SoundElem()
    }
    set {_uniqueStorage()._content = .soundElem(newValue)}
  }

  public var videoElem: VideoElem {
    get {
      if case .videoElem(let v)? = _storage._content {return v}
      return VideoElem()
    }
    set {_uniqueStorage()._content = .videoElem(newValue)}
  }

  public var fileElem: FileElem {
    get {
      if case .fileElem(let v)? = _storage._content {return v}
      return FileElem()
    }
    set {_uniqueStorage()._content = .fileElem(newValue)}
  }

  public var mergeElem: MergeElem {
    get {
      if case .mergeElem(let v)? = _storage._content {return v}
      return MergeElem()
    }
    set {_uniqueStorage()._content = .mergeElem(newValue)}
  }

  public var atTextElem: AtTextElem {
    get {
      if case .atTextElem(let v)? = _storage._content {return v}
      return AtTextElem()
    }
    set {_uniqueStorage()._content = .atTextElem(newValue)}
  }

  public var faceElem: FaceElem {
    get {
      if case .faceElem(let v)? = _storage._content {return v}
      return FaceElem()
    }
    set {_uniqueStorage()._content = .faceElem(newValue)}
  }

  public var locationElem: LocationElem {
    get {
      if case .locationElem(let v)? = _storage._content {return v}
      return LocationElem()
    }
    set {_uniqueStorage()._content = .locationElem(newValue)}
  }

  public var customElem: CustomElem {
    get {
      if case .customElem(let v)? = _storage._content {return v}
      return CustomElem()
    }
    set {_uniqueStorage()._content = .customElem(newValue)}
  }

  public var quoteElem: QuoteElem {
    get {
      if case .quoteElem(let v)? = _storage._content {return v}
      return QuoteElem()
    }
    set {_uniqueStorage()._content = .quoteElem(newValue)}
  }

  public var advancedTextElem: AdvancedTextElem {
    get {
      if case .advancedTextElem(let v)? = _storage._content {return v}
      return AdvancedTextElem()
    }
    set {_uniqueStorage()._content = .advancedTextElem(newValue)}
  }

  public var typingElem: TypingElem {
    get {
      if case .typingElem(let v)? = _storage._content {return v}
      return TypingElem()
    }
    set {_uniqueStorage()._content = .typingElem(newValue)}
  }

  public var streamElem: StreamElem {
    get {
      if case .streamElem(let v)? = _storage._content {return v}
      return StreamElem()
    }
    set {_uniqueStorage()._content = .streamElem(newValue)}
  }

  public var revokedTips: RevokedTips {
    get {
      if case .revokedTips(let v)? = _storage._content {return v}
      return RevokedTips()
    }
    set {_uniqueStorage()._content = .revokedTips(newValue)}
  }

  public var groupCreatedTips: GroupCreatedTips {
    get {
      if case .groupCreatedTips(let v)? = _storage._content {return v}
      return GroupCreatedTips()
    }
    set {_uniqueStorage()._content = .groupCreatedTips(newValue)}
  }

  ///    GroupInfoSetTips groupInfoSetTips = 39;
  ///    GroupInfoSetNameTips groupInfoSetNameTips = 40;
  ///    GroupInfoSetAnnouncementTips groupInfoSetAnnouncementTips = 41;
  ///    JoinGroupApplicationTips joinGroupApplicationTips = 42;
  public var memberQuitTips: MemberQuitTips {
    get {
      if case .memberQuitTips(let v)? = _storage._content {return v}
      return MemberQuitTips()
    }
    set {_uniqueStorage()._content = .memberQuitTips(newValue)}
  }

  ///    GroupApplicationAcceptedTips groupApplicationAcceptedTips = 44;
  ///    GroupApplicationRejectedTips groupApplicationRejectedTips = 45;
  public var groupOwnerTransferredTips: GroupOwnerTransferredTips {
    get {
      if case .groupOwnerTransferredTips(let v)? = _storage._content {return v}
      return GroupOwnerTransferredTips()
    }
    set {_uniqueStorage()._content = .groupOwnerTransferredTips(newValue)}
  }

  public var memberKickedTips: MemberKickedTips {
    get {
      if case .memberKickedTips(let v)? = _storage._content {return v}
      return MemberKickedTips()
    }
    set {_uniqueStorage()._content = .memberKickedTips(newValue)}
  }

  public var memberInvitedTips: MemberInvitedTips {
    get {
      if case .memberInvitedTips(let v)? = _storage._content {return v}
      return MemberInvitedTips()
    }
    set {_uniqueStorage()._content = .memberInvitedTips(newValue)}
  }

  public var memberEnterTips: MemberEnterTips {
    get {
      if case .memberEnterTips(let v)? = _storage._content {return v}
      return MemberEnterTips()
    }
    set {_uniqueStorage()._content = .memberEnterTips(newValue)}
  }

  public var groupDismissedTips: GroupDismissedTips {
    get {
      if case .groupDismissedTips(let v)? = _storage._content {return v}
      return GroupDismissedTips()
    }
    set {_uniqueStorage()._content = .groupDismissedTips(newValue)}
  }

  public var groupMemberMutedTips: GroupMemberMutedTips {
    get {
      if case .groupMemberMutedTips(let v)? = _storage._content {return v}
      return GroupMemberMutedTips()
    }
    set {_uniqueStorage()._content = .groupMemberMutedTips(newValue)}
  }

  public var groupMemberCancelMutedTips: GroupMemberCancelMutedTips {
    get {
      if case .groupMemberCancelMutedTips(let v)? = _storage._content {return v}
      return GroupMemberCancelMutedTips()
    }
    set {_uniqueStorage()._content = .groupMemberCancelMutedTips(newValue)}
  }

  public var groupMutedTips: GroupMutedTips {
    get {
      if case .groupMutedTips(let v)? = _storage._content {return v}
      return GroupMutedTips()
    }
    set {_uniqueStorage()._content = .groupMutedTips(newValue)}
  }

  public var groupCancelMutedTips: GroupCancelMutedTips {
    get {
      if case .groupCancelMutedTips(let v)? = _storage._content {return v}
      return GroupCancelMutedTips()
    }
    set {_uniqueStorage()._content = .groupCancelMutedTips(newValue)}
  }

  ///    GroupMemberInfoSetTips groupMemberInfoSetTips = 55;
  ///    FriendApplicationTips friendApplicationTips = 56;
  public var friendApplicationApprovedTips: FriendApplicationApprovedTips {
    get {
      if case .friendApplicationApprovedTips(let v)? = _storage._content {return v}
      return FriendApplicationApprovedTips()
    }
    set {_uniqueStorage()._content = .friendApplicationApprovedTips(newValue)}
  }

  ///    FriendApplicationRejectedTips friendApplicationRejectedTips = 58;
  ///    FriendAddedTips friendAddedTips = 59;
  ///    FriendDeletedTips friendDeletedTips = 60;
  ///    BlackAddedTips blackAddedTips = 61;
  ///    BlackDeletedTips blackDeletedTips = 62;
  ///    FriendInfoChangedTips friendInfoChangedTips = 63;
  ///    UserInfoUpdatedTips userInfoUpdatedTips = 64;
  ///    UserStatusChangeTips userStatusChangeTips = 65;
  ///    UserCommandAddTips userCommandAddTips = 66;
  ///    UserCommandUpdateTips userCommandUpdateTips = 67;
  ///    UserCommandDeleteTips userCommandDeleteTips = 68;
  ///    ConversationUpdateTips conversationUpdateTips = 69;
  ///    ConversationSetPrivateTips conversationSetPrivateTips = 70;
  ///    ConversationHasReadTips conversationHasReadTips = 71;
  ///    DeleteMessageTips deleteMessageTips = 72;
  ///    RevokedTips revokedTips = 73;
  ///    ClearConversationTips clearConversationTips = 74;
  ///    DeleteMsgsTips deleteMsgsTips = 75;
  ///    MarkAsReadTips markAsReadTips = 76;
  ///    FriendsInfoUpdateTips friendsInfoUpdateTips = 77;
  ///    SubUserOnlineStatusTips subUserOnlineStatusTips = 78;
  ///    StreamMsgTips streamMsgTips = 79;
  public var conversationPrivateChatTips: ConversationPrivateChatTips {
    get {
      if case .conversationPrivateChatTips(let v)? = _storage._content {return v}
      return ConversationPrivateChatTips()
    }
    set {_uniqueStorage()._content = .conversationPrivateChatTips(newValue)}
  }

  public var businessTips: BusinessTips {
    get {
      if case .businessTips(let v)? = _storage._content {return v}
      return BusinessTips()
    }
    set {_uniqueStorage()._content = .businessTips(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable, Sendable {
    case textElem(TextElem)
    case cardElem(CardElem)
    case pictureElem(PictureElem)
    case soundElem(SoundElem)
    case videoElem(VideoElem)
    case fileElem(FileElem)
    case mergeElem(MergeElem)
    case atTextElem(AtTextElem)
    case faceElem(FaceElem)
    case locationElem(LocationElem)
    case customElem(CustomElem)
    case quoteElem(QuoteElem)
    case advancedTextElem(AdvancedTextElem)
    case typingElem(TypingElem)
    case streamElem(StreamElem)
    case revokedTips(RevokedTips)
    case groupCreatedTips(GroupCreatedTips)
    ///    GroupInfoSetTips groupInfoSetTips = 39;
    ///    GroupInfoSetNameTips groupInfoSetNameTips = 40;
    ///    GroupInfoSetAnnouncementTips groupInfoSetAnnouncementTips = 41;
    ///    JoinGroupApplicationTips joinGroupApplicationTips = 42;
    case memberQuitTips(MemberQuitTips)
    ///    GroupApplicationAcceptedTips groupApplicationAcceptedTips = 44;
    ///    GroupApplicationRejectedTips groupApplicationRejectedTips = 45;
    case groupOwnerTransferredTips(GroupOwnerTransferredTips)
    case memberKickedTips(MemberKickedTips)
    case memberInvitedTips(MemberInvitedTips)
    case memberEnterTips(MemberEnterTips)
    case groupDismissedTips(GroupDismissedTips)
    case groupMemberMutedTips(GroupMemberMutedTips)
    case groupMemberCancelMutedTips(GroupMemberCancelMutedTips)
    case groupMutedTips(GroupMutedTips)
    case groupCancelMutedTips(GroupCancelMutedTips)
    ///    GroupMemberInfoSetTips groupMemberInfoSetTips = 55;
    ///    FriendApplicationTips friendApplicationTips = 56;
    case friendApplicationApprovedTips(FriendApplicationApprovedTips)
    ///    FriendApplicationRejectedTips friendApplicationRejectedTips = 58;
    ///    FriendAddedTips friendAddedTips = 59;
    ///    FriendDeletedTips friendDeletedTips = 60;
    ///    BlackAddedTips blackAddedTips = 61;
    ///    BlackDeletedTips blackDeletedTips = 62;
    ///    FriendInfoChangedTips friendInfoChangedTips = 63;
    ///    UserInfoUpdatedTips userInfoUpdatedTips = 64;
    ///    UserStatusChangeTips userStatusChangeTips = 65;
    ///    UserCommandAddTips userCommandAddTips = 66;
    ///    UserCommandUpdateTips userCommandUpdateTips = 67;
    ///    UserCommandDeleteTips userCommandDeleteTips = 68;
    ///    ConversationUpdateTips conversationUpdateTips = 69;
    ///    ConversationSetPrivateTips conversationSetPrivateTips = 70;
    ///    ConversationHasReadTips conversationHasReadTips = 71;
    ///    DeleteMessageTips deleteMessageTips = 72;
    ///    RevokedTips revokedTips = 73;
    ///    ClearConversationTips clearConversationTips = 74;
    ///    DeleteMsgsTips deleteMsgsTips = 75;
    ///    MarkAsReadTips markAsReadTips = 76;
    ///    FriendsInfoUpdateTips friendsInfoUpdateTips = 77;
    ///    SubUserOnlineStatusTips subUserOnlineStatusTips = 78;
    ///    StreamMsgTips streamMsgTips = 79;
    case conversationPrivateChatTips(ConversationPrivateChatTips)
    case businessTips(BusinessTips)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "openim.sdk.shared"

extension GroupStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Default"),
    2: .same(proto: "Dismissed"),
  ]
}

extension GroupJoinSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "_"),
    1: .same(proto: "Admin"),
    2: .same(proto: "Invitation"),
    3: .same(proto: "Search"),
    4: .same(proto: "QRCode"),
  ]
}

extension GroupNeedVerification: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ApplyNeedVerificationInviteDirectly"),
    1: .same(proto: "AllNeedVerification"),
    2: .same(proto: "DirectAccess"),
  ]
}

extension GroupLookMemberInfo: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ProhibitGroupLookMemberInfo"),
    1: .same(proto: "AllowGroupLookMemberInfo"),
  ]
}

extension GroupApplyMemberFriend: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ProhibitGroupApplyMemberFriend"),
    1: .same(proto: "AllowGroupApplyMemberFriend"),
  ]
}

extension IMUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IMUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userID"),
    2: .same(proto: "nickname"),
    3: .same(proto: "faceURL"),
    4: .same(proto: "ex"),
    5: .same(proto: "createTime"),
    6: .same(proto: "globalRecvMsgOpt"),
    7: .same(proto: "attached"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.faceURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ex) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.createTime) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.globalRecvMsgOpt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.attached) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 2)
    }
    if !self.faceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.faceURL, fieldNumber: 3)
    }
    if !self.ex.isEmpty {
      try visitor.visitSingularStringField(value: self.ex, fieldNumber: 4)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 5)
    }
    if self.globalRecvMsgOpt != .normal {
      try visitor.visitSingularEnumField(value: self.globalRecvMsgOpt, fieldNumber: 6)
    }
    if !self.attached.isEmpty {
      try visitor.visitSingularStringField(value: self.attached, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMUser, rhs: IMUser) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.faceURL != rhs.faceURL {return false}
    if lhs.ex != rhs.ex {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.globalRecvMsgOpt != rhs.globalRecvMsgOpt {return false}
    if lhs.attached != rhs.attached {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommandInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userID"),
    2: .same(proto: "type"),
    3: .same(proto: "createTime"),
    4: .same(proto: "uuid"),
    5: .same(proto: "value"),
    6: .same(proto: "ex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.createTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.ex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 2)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 3)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 4)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 5)
    }
    if !self.ex.isEmpty {
      try visitor.visitSingularStringField(value: self.ex, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CommandInfo, rhs: CommandInfo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.value != rhs.value {return false}
    if lhs.ex != rhs.ex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMFriend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IMFriend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ownerUserID"),
    2: .same(proto: "friendUserID"),
    3: .same(proto: "remark"),
    4: .same(proto: "createTime"),
    5: .same(proto: "addSource"),
    6: .same(proto: "operatorUserID"),
    7: .same(proto: "nickname"),
    8: .same(proto: "faceURL"),
    9: .same(proto: "ex"),
    10: .same(proto: "attachedInfo"),
    11: .same(proto: "isPinned"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ownerUserID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.friendUserID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.createTime) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.addSource) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.operatorUserID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.faceURL) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.ex) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.attachedInfo) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.isPinned) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerUserID, fieldNumber: 1)
    }
    if !self.friendUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.friendUserID, fieldNumber: 2)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 3)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 4)
    }
    if self.addSource != 0 {
      try visitor.visitSingularInt32Field(value: self.addSource, fieldNumber: 5)
    }
    if !self.operatorUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.operatorUserID, fieldNumber: 6)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 7)
    }
    if !self.faceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.faceURL, fieldNumber: 8)
    }
    if !self.ex.isEmpty {
      try visitor.visitSingularStringField(value: self.ex, fieldNumber: 9)
    }
    if !self.attachedInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.attachedInfo, fieldNumber: 10)
    }
    if self.isPinned != false {
      try visitor.visitSingularBoolField(value: self.isPinned, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMFriend, rhs: IMFriend) -> Bool {
    if lhs.ownerUserID != rhs.ownerUserID {return false}
    if lhs.friendUserID != rhs.friendUserID {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.addSource != rhs.addSource {return false}
    if lhs.operatorUserID != rhs.operatorUserID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.faceURL != rhs.faceURL {return false}
    if lhs.ex != rhs.ex {return false}
    if lhs.attachedInfo != rhs.attachedInfo {return false}
    if lhs.isPinned != rhs.isPinned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMBlack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IMBlack"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ownerUserID"),
    2: .same(proto: "blockUserID"),
    3: .same(proto: "nickname"),
    4: .same(proto: "faceURL"),
    5: .same(proto: "createTime"),
    6: .same(proto: "addSource"),
    7: .same(proto: "operatorUserID"),
    8: .same(proto: "ex"),
    9: .same(proto: "attached"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ownerUserID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blockUserID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.faceURL) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.createTime) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.addSource) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.operatorUserID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.ex) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.attached) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerUserID, fieldNumber: 1)
    }
    if !self.blockUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockUserID, fieldNumber: 2)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 3)
    }
    if !self.faceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.faceURL, fieldNumber: 4)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 5)
    }
    if self.addSource != 0 {
      try visitor.visitSingularInt32Field(value: self.addSource, fieldNumber: 6)
    }
    if !self.operatorUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.operatorUserID, fieldNumber: 7)
    }
    if !self.ex.isEmpty {
      try visitor.visitSingularStringField(value: self.ex, fieldNumber: 8)
    }
    if !self.attached.isEmpty {
      try visitor.visitSingularStringField(value: self.attached, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMBlack, rhs: IMBlack) -> Bool {
    if lhs.ownerUserID != rhs.ownerUserID {return false}
    if lhs.blockUserID != rhs.blockUserID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.faceURL != rhs.faceURL {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.addSource != rhs.addSource {return false}
    if lhs.operatorUserID != rhs.operatorUserID {return false}
    if lhs.ex != rhs.ex {return false}
    if lhs.attached != rhs.attached {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMFriendApplication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IMFriendApplication"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fromUserID"),
    2: .same(proto: "fromNickname"),
    3: .same(proto: "fromFaceURL"),
    4: .same(proto: "toUserID"),
    5: .same(proto: "toNickname"),
    6: .same(proto: "toFaceURL"),
    7: .same(proto: "handleResult"),
    8: .same(proto: "reqMsg"),
    9: .same(proto: "createTime"),
    10: .same(proto: "handlerUserID"),
    11: .same(proto: "handleMsg"),
    12: .same(proto: "handleTime"),
    13: .same(proto: "ex"),
    14: .same(proto: "attached"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fromUserID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fromNickname) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fromFaceURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.toUserID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.toNickname) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.toFaceURL) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.handleResult) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.reqMsg) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.createTime) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.handlerUserID) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.handleMsg) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.handleTime) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.ex) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.attached) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fromUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.fromUserID, fieldNumber: 1)
    }
    if !self.fromNickname.isEmpty {
      try visitor.visitSingularStringField(value: self.fromNickname, fieldNumber: 2)
    }
    if !self.fromFaceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.fromFaceURL, fieldNumber: 3)
    }
    if !self.toUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.toUserID, fieldNumber: 4)
    }
    if !self.toNickname.isEmpty {
      try visitor.visitSingularStringField(value: self.toNickname, fieldNumber: 5)
    }
    if !self.toFaceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.toFaceURL, fieldNumber: 6)
    }
    if self.handleResult != 0 {
      try visitor.visitSingularInt32Field(value: self.handleResult, fieldNumber: 7)
    }
    if !self.reqMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.reqMsg, fieldNumber: 8)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 9)
    }
    if !self.handlerUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.handlerUserID, fieldNumber: 10)
    }
    if !self.handleMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.handleMsg, fieldNumber: 11)
    }
    if self.handleTime != 0 {
      try visitor.visitSingularInt64Field(value: self.handleTime, fieldNumber: 12)
    }
    if !self.ex.isEmpty {
      try visitor.visitSingularStringField(value: self.ex, fieldNumber: 13)
    }
    if !self.attached.isEmpty {
      try visitor.visitSingularStringField(value: self.attached, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMFriendApplication, rhs: IMFriendApplication) -> Bool {
    if lhs.fromUserID != rhs.fromUserID {return false}
    if lhs.fromNickname != rhs.fromNickname {return false}
    if lhs.fromFaceURL != rhs.fromFaceURL {return false}
    if lhs.toUserID != rhs.toUserID {return false}
    if lhs.toNickname != rhs.toNickname {return false}
    if lhs.toFaceURL != rhs.toFaceURL {return false}
    if lhs.handleResult != rhs.handleResult {return false}
    if lhs.reqMsg != rhs.reqMsg {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.handlerUserID != rhs.handlerUserID {return false}
    if lhs.handleMsg != rhs.handleMsg {return false}
    if lhs.handleTime != rhs.handleTime {return false}
    if lhs.ex != rhs.ex {return false}
    if lhs.attached != rhs.attached {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IMGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupID"),
    2: .same(proto: "groupName"),
    3: .same(proto: "notification"),
    4: .same(proto: "introduction"),
    5: .same(proto: "faceURL"),
    6: .same(proto: "ownerUserID"),
    7: .same(proto: "createTime"),
    8: .same(proto: "memberCount"),
    9: .same(proto: "ex"),
    10: .same(proto: "status"),
    11: .same(proto: "creatorUserID"),
    12: .same(proto: "needVerification"),
    13: .same(proto: "lookMemberInfo"),
    14: .same(proto: "applyMemberFriend"),
    15: .same(proto: "notificationUpdateTime"),
    16: .same(proto: "notificationUserID"),
    17: .same(proto: "attachedInfo"),
  ]

  fileprivate class _StorageClass {
    var _groupID: String = String()
    var _groupName: String = String()
    var _notification: String = String()
    var _introduction: String = String()
    var _faceURL: String = String()
    var _ownerUserID: String = String()
    var _createTime: Int64 = 0
    var _memberCount: Int64 = 0
    var _ex: String = String()
    var _status: GroupStatus = .default
    var _creatorUserID: String = String()
    var _needVerification: GroupNeedVerification = .applyNeedVerificationInviteDirectly
    var _lookMemberInfo: GroupLookMemberInfo = .prohibitGroupLookMemberInfo
    var _applyMemberFriend: GroupApplyMemberFriend = .prohibitGroupApplyMemberFriend
    var _notificationUpdateTime: Int64 = 0
    var _notificationUserID: String = String()
    var _attachedInfo: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _groupID = source._groupID
      _groupName = source._groupName
      _notification = source._notification
      _introduction = source._introduction
      _faceURL = source._faceURL
      _ownerUserID = source._ownerUserID
      _createTime = source._createTime
      _memberCount = source._memberCount
      _ex = source._ex
      _status = source._status
      _creatorUserID = source._creatorUserID
      _needVerification = source._needVerification
      _lookMemberInfo = source._lookMemberInfo
      _applyMemberFriend = source._applyMemberFriend
      _notificationUpdateTime = source._notificationUpdateTime
      _notificationUserID = source._notificationUserID
      _attachedInfo = source._attachedInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._groupID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._groupName) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._notification) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._introduction) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._faceURL) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._ownerUserID) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._createTime) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._memberCount) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._ex) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._creatorUserID) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._needVerification) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._lookMemberInfo) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._applyMemberFriend) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._notificationUpdateTime) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._notificationUserID) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._attachedInfo) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._groupID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupID, fieldNumber: 1)
      }
      if !_storage._groupName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupName, fieldNumber: 2)
      }
      if !_storage._notification.isEmpty {
        try visitor.visitSingularStringField(value: _storage._notification, fieldNumber: 3)
      }
      if !_storage._introduction.isEmpty {
        try visitor.visitSingularStringField(value: _storage._introduction, fieldNumber: 4)
      }
      if !_storage._faceURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._faceURL, fieldNumber: 5)
      }
      if !_storage._ownerUserID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerUserID, fieldNumber: 6)
      }
      if _storage._createTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createTime, fieldNumber: 7)
      }
      if _storage._memberCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._memberCount, fieldNumber: 8)
      }
      if !_storage._ex.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ex, fieldNumber: 9)
      }
      if _storage._status != .default {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 10)
      }
      if !_storage._creatorUserID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._creatorUserID, fieldNumber: 11)
      }
      if _storage._needVerification != .applyNeedVerificationInviteDirectly {
        try visitor.visitSingularEnumField(value: _storage._needVerification, fieldNumber: 12)
      }
      if _storage._lookMemberInfo != .prohibitGroupLookMemberInfo {
        try visitor.visitSingularEnumField(value: _storage._lookMemberInfo, fieldNumber: 13)
      }
      if _storage._applyMemberFriend != .prohibitGroupApplyMemberFriend {
        try visitor.visitSingularEnumField(value: _storage._applyMemberFriend, fieldNumber: 14)
      }
      if _storage._notificationUpdateTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._notificationUpdateTime, fieldNumber: 15)
      }
      if !_storage._notificationUserID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._notificationUserID, fieldNumber: 16)
      }
      if !_storage._attachedInfo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._attachedInfo, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMGroup, rhs: IMGroup) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._groupName != rhs_storage._groupName {return false}
        if _storage._notification != rhs_storage._notification {return false}
        if _storage._introduction != rhs_storage._introduction {return false}
        if _storage._faceURL != rhs_storage._faceURL {return false}
        if _storage._ownerUserID != rhs_storage._ownerUserID {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._memberCount != rhs_storage._memberCount {return false}
        if _storage._ex != rhs_storage._ex {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._creatorUserID != rhs_storage._creatorUserID {return false}
        if _storage._needVerification != rhs_storage._needVerification {return false}
        if _storage._lookMemberInfo != rhs_storage._lookMemberInfo {return false}
        if _storage._applyMemberFriend != rhs_storage._applyMemberFriend {return false}
        if _storage._notificationUpdateTime != rhs_storage._notificationUpdateTime {return false}
        if _storage._notificationUserID != rhs_storage._notificationUserID {return false}
        if _storage._attachedInfo != rhs_storage._attachedInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMGroupMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IMGroupMember"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupID"),
    2: .same(proto: "userID"),
    3: .same(proto: "nickname"),
    4: .same(proto: "faceURL"),
    5: .same(proto: "roleLevel"),
    6: .same(proto: "joinTime"),
    7: .same(proto: "joinSource"),
    8: .same(proto: "inviterUserID"),
    9: .same(proto: "muteEndTime"),
    10: .same(proto: "operatorUserID"),
    11: .same(proto: "ex"),
    12: .same(proto: "attachedInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.faceURL) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.roleLevel) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.joinTime) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.joinSource) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.inviterUserID) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.muteEndTime) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.operatorUserID) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.ex) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.attachedInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 3)
    }
    if !self.faceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.faceURL, fieldNumber: 4)
    }
    if self.roleLevel != 0 {
      try visitor.visitSingularInt32Field(value: self.roleLevel, fieldNumber: 5)
    }
    if self.joinTime != 0 {
      try visitor.visitSingularInt64Field(value: self.joinTime, fieldNumber: 6)
    }
    if self.joinSource != .___ {
      try visitor.visitSingularEnumField(value: self.joinSource, fieldNumber: 7)
    }
    if !self.inviterUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.inviterUserID, fieldNumber: 8)
    }
    if self.muteEndTime != 0 {
      try visitor.visitSingularInt64Field(value: self.muteEndTime, fieldNumber: 9)
    }
    if !self.operatorUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.operatorUserID, fieldNumber: 10)
    }
    if !self.ex.isEmpty {
      try visitor.visitSingularStringField(value: self.ex, fieldNumber: 11)
    }
    if !self.attachedInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.attachedInfo, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMGroupMember, rhs: IMGroupMember) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.faceURL != rhs.faceURL {return false}
    if lhs.roleLevel != rhs.roleLevel {return false}
    if lhs.joinTime != rhs.joinTime {return false}
    if lhs.joinSource != rhs.joinSource {return false}
    if lhs.inviterUserID != rhs.inviterUserID {return false}
    if lhs.muteEndTime != rhs.muteEndTime {return false}
    if lhs.operatorUserID != rhs.operatorUserID {return false}
    if lhs.ex != rhs.ex {return false}
    if lhs.attachedInfo != rhs.attachedInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMGroupApplication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IMGroupApplication"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupID"),
    2: .same(proto: "groupName"),
    3: .same(proto: "notification"),
    4: .same(proto: "introduction"),
    5: .same(proto: "groupFaceURL"),
    6: .same(proto: "createTime"),
    7: .same(proto: "status"),
    8: .same(proto: "creatorUserID"),
    9: .same(proto: "ownerUserID"),
    10: .same(proto: "memberCount"),
    11: .same(proto: "userID"),
    12: .same(proto: "nickname"),
    13: .same(proto: "userFaceURL"),
    14: .same(proto: "handleResult"),
    15: .same(proto: "reqMsg"),
    16: .same(proto: "handledMsg"),
    17: .same(proto: "reqTime"),
    18: .same(proto: "handleUserID"),
    19: .same(proto: "handledTime"),
    20: .same(proto: "ex"),
    21: .same(proto: "attachedInfo"),
    22: .same(proto: "joinSource"),
    23: .same(proto: "inviterUserID"),
  ]

  fileprivate class _StorageClass {
    var _groupID: String = String()
    var _groupName: String = String()
    var _notification: String = String()
    var _introduction: String = String()
    var _groupFaceURL: String = String()
    var _createTime: Int64 = 0
    var _status: Int32 = 0
    var _creatorUserID: String = String()
    var _ownerUserID: String = String()
    var _memberCount: Int32 = 0
    var _userID: String = String()
    var _nickname: String = String()
    var _userFaceURL: String = String()
    var _handleResult: Int32 = 0
    var _reqMsg: String = String()
    var _handledMsg: String = String()
    var _reqTime: Int64 = 0
    var _handleUserID: String = String()
    var _handledTime: Int64 = 0
    var _ex: String = String()
    var _attachedInfo: String = String()
    var _joinSource: GroupJoinSource = .___
    var _inviterUserID: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _groupID = source._groupID
      _groupName = source._groupName
      _notification = source._notification
      _introduction = source._introduction
      _groupFaceURL = source._groupFaceURL
      _createTime = source._createTime
      _status = source._status
      _creatorUserID = source._creatorUserID
      _ownerUserID = source._ownerUserID
      _memberCount = source._memberCount
      _userID = source._userID
      _nickname = source._nickname
      _userFaceURL = source._userFaceURL
      _handleResult = source._handleResult
      _reqMsg = source._reqMsg
      _handledMsg = source._handledMsg
      _reqTime = source._reqTime
      _handleUserID = source._handleUserID
      _handledTime = source._handledTime
      _ex = source._ex
      _attachedInfo = source._attachedInfo
      _joinSource = source._joinSource
      _inviterUserID = source._inviterUserID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._groupID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._groupName) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._notification) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._introduction) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._groupFaceURL) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._createTime) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._status) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._creatorUserID) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._ownerUserID) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._memberCount) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._nickname) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._userFaceURL) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._handleResult) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._reqMsg) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._handledMsg) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._reqTime) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._handleUserID) }()
        case 19: try { try decoder.decodeSingularInt64Field(value: &_storage._handledTime) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._ex) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._attachedInfo) }()
        case 22: try { try decoder.decodeSingularEnumField(value: &_storage._joinSource) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._inviterUserID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._groupID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupID, fieldNumber: 1)
      }
      if !_storage._groupName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupName, fieldNumber: 2)
      }
      if !_storage._notification.isEmpty {
        try visitor.visitSingularStringField(value: _storage._notification, fieldNumber: 3)
      }
      if !_storage._introduction.isEmpty {
        try visitor.visitSingularStringField(value: _storage._introduction, fieldNumber: 4)
      }
      if !_storage._groupFaceURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupFaceURL, fieldNumber: 5)
      }
      if _storage._createTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createTime, fieldNumber: 6)
      }
      if _storage._status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._status, fieldNumber: 7)
      }
      if !_storage._creatorUserID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._creatorUserID, fieldNumber: 8)
      }
      if !_storage._ownerUserID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerUserID, fieldNumber: 9)
      }
      if _storage._memberCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._memberCount, fieldNumber: 10)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 11)
      }
      if !_storage._nickname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nickname, fieldNumber: 12)
      }
      if !_storage._userFaceURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userFaceURL, fieldNumber: 13)
      }
      if _storage._handleResult != 0 {
        try visitor.visitSingularInt32Field(value: _storage._handleResult, fieldNumber: 14)
      }
      if !_storage._reqMsg.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reqMsg, fieldNumber: 15)
      }
      if !_storage._handledMsg.isEmpty {
        try visitor.visitSingularStringField(value: _storage._handledMsg, fieldNumber: 16)
      }
      if _storage._reqTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._reqTime, fieldNumber: 17)
      }
      if !_storage._handleUserID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._handleUserID, fieldNumber: 18)
      }
      if _storage._handledTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._handledTime, fieldNumber: 19)
      }
      if !_storage._ex.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ex, fieldNumber: 20)
      }
      if !_storage._attachedInfo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._attachedInfo, fieldNumber: 21)
      }
      if _storage._joinSource != .___ {
        try visitor.visitSingularEnumField(value: _storage._joinSource, fieldNumber: 22)
      }
      if !_storage._inviterUserID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._inviterUserID, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMGroupApplication, rhs: IMGroupApplication) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._groupName != rhs_storage._groupName {return false}
        if _storage._notification != rhs_storage._notification {return false}
        if _storage._introduction != rhs_storage._introduction {return false}
        if _storage._groupFaceURL != rhs_storage._groupFaceURL {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._creatorUserID != rhs_storage._creatorUserID {return false}
        if _storage._ownerUserID != rhs_storage._ownerUserID {return false}
        if _storage._memberCount != rhs_storage._memberCount {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._nickname != rhs_storage._nickname {return false}
        if _storage._userFaceURL != rhs_storage._userFaceURL {return false}
        if _storage._handleResult != rhs_storage._handleResult {return false}
        if _storage._reqMsg != rhs_storage._reqMsg {return false}
        if _storage._handledMsg != rhs_storage._handledMsg {return false}
        if _storage._reqTime != rhs_storage._reqTime {return false}
        if _storage._handleUserID != rhs_storage._handleUserID {return false}
        if _storage._handledTime != rhs_storage._handledTime {return false}
        if _storage._ex != rhs_storage._ex {return false}
        if _storage._attachedInfo != rhs_storage._attachedInfo {return false}
        if _storage._joinSource != rhs_storage._joinSource {return false}
        if _storage._inviterUserID != rhs_storage._inviterUserID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMConversation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IMConversation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversationID"),
    2: .same(proto: "conversationType"),
    3: .same(proto: "userID"),
    4: .same(proto: "groupID"),
    5: .same(proto: "showName"),
    6: .same(proto: "faceURL"),
    7: .same(proto: "recvMsgOpt"),
    8: .same(proto: "unreadCount"),
    9: .same(proto: "groupAtType"),
    10: .same(proto: "latestMsg"),
    11: .same(proto: "latestMsgSendTime"),
    12: .same(proto: "draftText"),
    13: .same(proto: "draftTextTime"),
    14: .same(proto: "isPinned"),
    15: .same(proto: "isPrivateChat"),
    16: .same(proto: "burnDuration"),
    17: .same(proto: "ex"),
    18: .same(proto: "msgDestructTime"),
    19: .same(proto: "isMsgDestruct"),
  ]

  fileprivate class _StorageClass {
    var _conversationID: String = String()
    var _conversationType: SessionType = .sessionType_
    var _userID: String = String()
    var _groupID: String = String()
    var _showName: String = String()
    var _faceURL: String = String()
    var _recvMsgOpt: ConvRecvMsgOpt = .receiveMessage
    var _unreadCount: Int32 = 0
    var _groupAtType: ConvGroupAtType = .atNormal
    var _latestMsg: IMMessage? = nil
    var _latestMsgSendTime: Int64 = 0
    var _draftText: String = String()
    var _draftTextTime: Int64 = 0
    var _isPinned: Bool = false
    var _isPrivateChat: Bool = false
    var _burnDuration: Int32 = 0
    var _ex: String = String()
    var _msgDestructTime: Int64 = 0
    var _isMsgDestruct: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _conversationID = source._conversationID
      _conversationType = source._conversationType
      _userID = source._userID
      _groupID = source._groupID
      _showName = source._showName
      _faceURL = source._faceURL
      _recvMsgOpt = source._recvMsgOpt
      _unreadCount = source._unreadCount
      _groupAtType = source._groupAtType
      _latestMsg = source._latestMsg
      _latestMsgSendTime = source._latestMsgSendTime
      _draftText = source._draftText
      _draftTextTime = source._draftTextTime
      _isPinned = source._isPinned
      _isPrivateChat = source._isPrivateChat
      _burnDuration = source._burnDuration
      _ex = source._ex
      _msgDestructTime = source._msgDestructTime
      _isMsgDestruct = source._isMsgDestruct
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._conversationID) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._conversationType) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._groupID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._showName) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._faceURL) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._recvMsgOpt) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._unreadCount) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._groupAtType) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._latestMsg) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._latestMsgSendTime) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._draftText) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._draftTextTime) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._isPinned) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._isPrivateChat) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._burnDuration) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._ex) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._msgDestructTime) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._isMsgDestruct) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._conversationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._conversationID, fieldNumber: 1)
      }
      if _storage._conversationType != .sessionType_ {
        try visitor.visitSingularEnumField(value: _storage._conversationType, fieldNumber: 2)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 3)
      }
      if !_storage._groupID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupID, fieldNumber: 4)
      }
      if !_storage._showName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._showName, fieldNumber: 5)
      }
      if !_storage._faceURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._faceURL, fieldNumber: 6)
      }
      if _storage._recvMsgOpt != .receiveMessage {
        try visitor.visitSingularEnumField(value: _storage._recvMsgOpt, fieldNumber: 7)
      }
      if _storage._unreadCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._unreadCount, fieldNumber: 8)
      }
      if _storage._groupAtType != .atNormal {
        try visitor.visitSingularEnumField(value: _storage._groupAtType, fieldNumber: 9)
      }
      try { if let v = _storage._latestMsg {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._latestMsgSendTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestMsgSendTime, fieldNumber: 11)
      }
      if !_storage._draftText.isEmpty {
        try visitor.visitSingularStringField(value: _storage._draftText, fieldNumber: 12)
      }
      if _storage._draftTextTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._draftTextTime, fieldNumber: 13)
      }
      if _storage._isPinned != false {
        try visitor.visitSingularBoolField(value: _storage._isPinned, fieldNumber: 14)
      }
      if _storage._isPrivateChat != false {
        try visitor.visitSingularBoolField(value: _storage._isPrivateChat, fieldNumber: 15)
      }
      if _storage._burnDuration != 0 {
        try visitor.visitSingularInt32Field(value: _storage._burnDuration, fieldNumber: 16)
      }
      if !_storage._ex.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ex, fieldNumber: 17)
      }
      if _storage._msgDestructTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._msgDestructTime, fieldNumber: 18)
      }
      if _storage._isMsgDestruct != false {
        try visitor.visitSingularBoolField(value: _storage._isMsgDestruct, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMConversation, rhs: IMConversation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._conversationID != rhs_storage._conversationID {return false}
        if _storage._conversationType != rhs_storage._conversationType {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._showName != rhs_storage._showName {return false}
        if _storage._faceURL != rhs_storage._faceURL {return false}
        if _storage._recvMsgOpt != rhs_storage._recvMsgOpt {return false}
        if _storage._unreadCount != rhs_storage._unreadCount {return false}
        if _storage._groupAtType != rhs_storage._groupAtType {return false}
        if _storage._latestMsg != rhs_storage._latestMsg {return false}
        if _storage._latestMsgSendTime != rhs_storage._latestMsgSendTime {return false}
        if _storage._draftText != rhs_storage._draftText {return false}
        if _storage._draftTextTime != rhs_storage._draftTextTime {return false}
        if _storage._isPinned != rhs_storage._isPinned {return false}
        if _storage._isPrivateChat != rhs_storage._isPrivateChat {return false}
        if _storage._burnDuration != rhs_storage._burnDuration {return false}
        if _storage._ex != rhs_storage._ex {return false}
        if _storage._msgDestructTime != rhs_storage._msgDestructTime {return false}
        if _storage._isMsgDestruct != rhs_storage._isMsgDestruct {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AtInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AtInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "atUserID"),
    2: .same(proto: "groupNickname"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.atUserID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupNickname) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.atUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.atUserID, fieldNumber: 1)
    }
    if !self.groupNickname.isEmpty {
      try visitor.visitSingularStringField(value: self.groupNickname, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AtInfo, rhs: AtInfo) -> Bool {
    if lhs.atUserID != rhs.atUserID {return false}
    if lhs.groupNickname != rhs.groupNickname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "type"),
    4: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImageInfo, rhs: ImageInfo) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.type != rhs.type {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PictureBaseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PictureBaseInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "type"),
    3: .same(proto: "size"),
    4: .same(proto: "width"),
    5: .same(proto: "height"),
    6: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 3)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 5)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PictureBaseInfo, rhs: PictureBaseInfo) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.type != rhs.type {return false}
    if lhs.size != rhs.size {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SoundBaseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SoundBaseInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "soundPath"),
    3: .same(proto: "sourceURL"),
    4: .same(proto: "dataSize"),
    5: .same(proto: "duration"),
    6: .same(proto: "soundType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.soundPath) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sourceURL) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.dataSize) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.soundType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.soundPath.isEmpty {
      try visitor.visitSingularStringField(value: self.soundPath, fieldNumber: 2)
    }
    if !self.sourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceURL, fieldNumber: 3)
    }
    if self.dataSize != 0 {
      try visitor.visitSingularInt64Field(value: self.dataSize, fieldNumber: 4)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 5)
    }
    if !self.soundType.isEmpty {
      try visitor.visitSingularStringField(value: self.soundType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SoundBaseInfo, rhs: SoundBaseInfo) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.soundPath != rhs.soundPath {return false}
    if lhs.sourceURL != rhs.sourceURL {return false}
    if lhs.dataSize != rhs.dataSize {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.soundType != rhs.soundType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VideoBaseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VideoBaseInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "videoPath"),
    2: .same(proto: "videoUUID"),
    3: .same(proto: "videoURL"),
    4: .same(proto: "videoType"),
    5: .same(proto: "videoSize"),
    6: .same(proto: "duration"),
    7: .same(proto: "snapshotPath"),
    8: .same(proto: "snapshotUUID"),
    9: .same(proto: "snapshotSize"),
    10: .same(proto: "snapshotURL"),
    11: .same(proto: "snapshotWidth"),
    12: .same(proto: "snapshotHeight"),
    13: .same(proto: "snapshotType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.videoPath) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.videoUuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.videoURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.videoType) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.videoSize) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.snapshotPath) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.snapshotUuid) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.snapshotSize) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.snapshotURL) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.snapshotWidth) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.snapshotHeight) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.snapshotType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.videoPath.isEmpty {
      try visitor.visitSingularStringField(value: self.videoPath, fieldNumber: 1)
    }
    if !self.videoUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.videoUuid, fieldNumber: 2)
    }
    if !self.videoURL.isEmpty {
      try visitor.visitSingularStringField(value: self.videoURL, fieldNumber: 3)
    }
    if !self.videoType.isEmpty {
      try visitor.visitSingularStringField(value: self.videoType, fieldNumber: 4)
    }
    if self.videoSize != 0 {
      try visitor.visitSingularInt64Field(value: self.videoSize, fieldNumber: 5)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 6)
    }
    if !self.snapshotPath.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshotPath, fieldNumber: 7)
    }
    if !self.snapshotUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshotUuid, fieldNumber: 8)
    }
    if self.snapshotSize != 0 {
      try visitor.visitSingularInt64Field(value: self.snapshotSize, fieldNumber: 9)
    }
    if !self.snapshotURL.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshotURL, fieldNumber: 10)
    }
    if self.snapshotWidth != 0 {
      try visitor.visitSingularInt32Field(value: self.snapshotWidth, fieldNumber: 11)
    }
    if self.snapshotHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.snapshotHeight, fieldNumber: 12)
    }
    if !self.snapshotType.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshotType, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VideoBaseInfo, rhs: VideoBaseInfo) -> Bool {
    if lhs.videoPath != rhs.videoPath {return false}
    if lhs.videoUuid != rhs.videoUuid {return false}
    if lhs.videoURL != rhs.videoURL {return false}
    if lhs.videoType != rhs.videoType {return false}
    if lhs.videoSize != rhs.videoSize {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.snapshotPath != rhs.snapshotPath {return false}
    if lhs.snapshotUuid != rhs.snapshotUuid {return false}
    if lhs.snapshotSize != rhs.snapshotSize {return false}
    if lhs.snapshotURL != rhs.snapshotURL {return false}
    if lhs.snapshotWidth != rhs.snapshotWidth {return false}
    if lhs.snapshotHeight != rhs.snapshotHeight {return false}
    if lhs.snapshotType != rhs.snapshotType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileBaseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileBaseInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filePath"),
    2: .same(proto: "uuid"),
    3: .same(proto: "sourceURL"),
    4: .same(proto: "fileName"),
    5: .same(proto: "fileSize"),
    6: .same(proto: "fileType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filePath) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sourceURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.fileSize) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.fileType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 1)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 2)
    }
    if !self.sourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceURL, fieldNumber: 3)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 4)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularInt64Field(value: self.fileSize, fieldNumber: 5)
    }
    if !self.fileType.isEmpty {
      try visitor.visitSingularStringField(value: self.fileType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileBaseInfo, rhs: FileBaseInfo) -> Bool {
    if lhs.filePath != rhs.filePath {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.sourceURL != rhs.sourceURL {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.fileType != rhs.fileType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TextElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TextElem, rhs: TextElem) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CardElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userID"),
    2: .same(proto: "nickname"),
    3: .same(proto: "faceURL"),
    4: .same(proto: "ex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.faceURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 2)
    }
    if !self.faceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.faceURL, fieldNumber: 3)
    }
    if !self.ex.isEmpty {
      try visitor.visitSingularStringField(value: self.ex, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CardElem, rhs: CardElem) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.faceURL != rhs.faceURL {return false}
    if lhs.ex != rhs.ex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PictureElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PictureElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sourcePath"),
    2: .same(proto: "sourcePicture"),
    3: .same(proto: "bigPicture"),
    4: .same(proto: "snapshotPicture"),
  ]

  fileprivate class _StorageClass {
    var _sourcePath: String = String()
    var _sourcePicture: PictureBaseInfo? = nil
    var _bigPicture: PictureBaseInfo? = nil
    var _snapshotPicture: PictureBaseInfo? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _sourcePath = source._sourcePath
      _sourcePicture = source._sourcePicture
      _bigPicture = source._bigPicture
      _snapshotPicture = source._snapshotPicture
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._sourcePath) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._sourcePicture) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._bigPicture) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._snapshotPicture) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._sourcePath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sourcePath, fieldNumber: 1)
      }
      try { if let v = _storage._sourcePicture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._bigPicture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._snapshotPicture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PictureElem, rhs: PictureElem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sourcePath != rhs_storage._sourcePath {return false}
        if _storage._sourcePicture != rhs_storage._sourcePicture {return false}
        if _storage._bigPicture != rhs_storage._bigPicture {return false}
        if _storage._snapshotPicture != rhs_storage._snapshotPicture {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SoundElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SoundElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "soundPath"),
    3: .same(proto: "sourceURL"),
    4: .same(proto: "dataSize"),
    5: .same(proto: "duration"),
    6: .same(proto: "soundType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.soundPath) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sourceURL) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.dataSize) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.soundType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.soundPath.isEmpty {
      try visitor.visitSingularStringField(value: self.soundPath, fieldNumber: 2)
    }
    if !self.sourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceURL, fieldNumber: 3)
    }
    if self.dataSize != 0 {
      try visitor.visitSingularInt64Field(value: self.dataSize, fieldNumber: 4)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 5)
    }
    if !self.soundType.isEmpty {
      try visitor.visitSingularStringField(value: self.soundType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SoundElem, rhs: SoundElem) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.soundPath != rhs.soundPath {return false}
    if lhs.sourceURL != rhs.sourceURL {return false}
    if lhs.dataSize != rhs.dataSize {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.soundType != rhs.soundType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VideoElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VideoElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "videoPath"),
    2: .same(proto: "videoUUID"),
    3: .same(proto: "videoURL"),
    4: .same(proto: "videoType"),
    5: .same(proto: "videoSize"),
    6: .same(proto: "duration"),
    7: .same(proto: "snapshotPath"),
    8: .same(proto: "snapshotUUID"),
    9: .same(proto: "snapshotSize"),
    10: .same(proto: "snapshotURL"),
    11: .same(proto: "snapshotWidth"),
    12: .same(proto: "snapshotHeight"),
    13: .same(proto: "snapshotType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.videoPath) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.videoUuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.videoURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.videoType) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.videoSize) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.snapshotPath) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.snapshotUuid) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.snapshotSize) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.snapshotURL) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.snapshotWidth) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.snapshotHeight) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.snapshotType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.videoPath.isEmpty {
      try visitor.visitSingularStringField(value: self.videoPath, fieldNumber: 1)
    }
    if !self.videoUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.videoUuid, fieldNumber: 2)
    }
    if !self.videoURL.isEmpty {
      try visitor.visitSingularStringField(value: self.videoURL, fieldNumber: 3)
    }
    if !self.videoType.isEmpty {
      try visitor.visitSingularStringField(value: self.videoType, fieldNumber: 4)
    }
    if self.videoSize != 0 {
      try visitor.visitSingularInt64Field(value: self.videoSize, fieldNumber: 5)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 6)
    }
    if !self.snapshotPath.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshotPath, fieldNumber: 7)
    }
    if !self.snapshotUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshotUuid, fieldNumber: 8)
    }
    if self.snapshotSize != 0 {
      try visitor.visitSingularInt64Field(value: self.snapshotSize, fieldNumber: 9)
    }
    if !self.snapshotURL.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshotURL, fieldNumber: 10)
    }
    if self.snapshotWidth != 0 {
      try visitor.visitSingularInt32Field(value: self.snapshotWidth, fieldNumber: 11)
    }
    if self.snapshotHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.snapshotHeight, fieldNumber: 12)
    }
    if !self.snapshotType.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshotType, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VideoElem, rhs: VideoElem) -> Bool {
    if lhs.videoPath != rhs.videoPath {return false}
    if lhs.videoUuid != rhs.videoUuid {return false}
    if lhs.videoURL != rhs.videoURL {return false}
    if lhs.videoType != rhs.videoType {return false}
    if lhs.videoSize != rhs.videoSize {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.snapshotPath != rhs.snapshotPath {return false}
    if lhs.snapshotUuid != rhs.snapshotUuid {return false}
    if lhs.snapshotSize != rhs.snapshotSize {return false}
    if lhs.snapshotURL != rhs.snapshotURL {return false}
    if lhs.snapshotWidth != rhs.snapshotWidth {return false}
    if lhs.snapshotHeight != rhs.snapshotHeight {return false}
    if lhs.snapshotType != rhs.snapshotType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filePath"),
    2: .same(proto: "uuid"),
    3: .same(proto: "sourceURL"),
    4: .same(proto: "fileName"),
    5: .same(proto: "fileSize"),
    6: .same(proto: "fileType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filePath) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sourceURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.fileSize) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.fileType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 1)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 2)
    }
    if !self.sourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceURL, fieldNumber: 3)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 4)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularInt64Field(value: self.fileSize, fieldNumber: 5)
    }
    if !self.fileType.isEmpty {
      try visitor.visitSingularStringField(value: self.fileType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileElem, rhs: FileElem) -> Bool {
    if lhs.filePath != rhs.filePath {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.sourceURL != rhs.sourceURL {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.fileType != rhs.fileType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageEntity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "offset"),
    3: .same(proto: "length"),
    4: .same(proto: "url"),
    5: .same(proto: "ex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.length) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 2)
    }
    if self.length != 0 {
      try visitor.visitSingularInt32Field(value: self.length, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if !self.ex.isEmpty {
      try visitor.visitSingularStringField(value: self.ex, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageEntity, rhs: MessageEntity) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.length != rhs.length {return false}
    if lhs.url != rhs.url {return false}
    if lhs.ex != rhs.ex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MergeElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MergeElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "abstractList"),
    3: .same(proto: "multiMessage"),
    4: .same(proto: "messageEntityList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.abstractList) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.multiMessage) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.messageEntityList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.abstractList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.abstractList, fieldNumber: 2)
    }
    if !self.multiMessage.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.multiMessage, fieldNumber: 3)
    }
    if !self.messageEntityList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messageEntityList, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MergeElem, rhs: MergeElem) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.abstractList != rhs.abstractList {return false}
    if lhs.multiMessage != rhs.multiMessage {return false}
    if lhs.messageEntityList != rhs.messageEntityList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AtTextElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AtTextElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "atUserList"),
    3: .same(proto: "atUsersInfo"),
    4: .same(proto: "quoteMessage"),
    5: .same(proto: "isAtSelf"),
  ]

  fileprivate class _StorageClass {
    var _text: String = String()
    var _atUserList: [String] = []
    var _atUsersInfo: [AtInfo] = []
    var _quoteMessage: IMMessage? = nil
    var _isAtSelf: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _text = source._text
      _atUserList = source._atUserList
      _atUsersInfo = source._atUsersInfo
      _quoteMessage = source._quoteMessage
      _isAtSelf = source._isAtSelf
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._text) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._atUserList) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._atUsersInfo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._quoteMessage) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isAtSelf) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._text.isEmpty {
        try visitor.visitSingularStringField(value: _storage._text, fieldNumber: 1)
      }
      if !_storage._atUserList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._atUserList, fieldNumber: 2)
      }
      if !_storage._atUsersInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._atUsersInfo, fieldNumber: 3)
      }
      try { if let v = _storage._quoteMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._isAtSelf != false {
        try visitor.visitSingularBoolField(value: _storage._isAtSelf, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AtTextElem, rhs: AtTextElem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._text != rhs_storage._text {return false}
        if _storage._atUserList != rhs_storage._atUserList {return false}
        if _storage._atUsersInfo != rhs_storage._atUsersInfo {return false}
        if _storage._quoteMessage != rhs_storage._quoteMessage {return false}
        if _storage._isAtSelf != rhs_storage._isAtSelf {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FaceElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FaceElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FaceElem, rhs: FaceElem) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LocationElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocationElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .same(proto: "longitude"),
    3: .same(proto: "latitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 1)
    }
    if self.longitude.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 2)
    }
    if self.latitude.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LocationElem, rhs: LocationElem) -> Bool {
    if lhs.description_p != rhs.description_p {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CustomElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "description"),
    3: .same(proto: "extension"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.`extension`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.`extension`.isEmpty {
      try visitor.visitSingularStringField(value: self.`extension`, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CustomElem, rhs: CustomElem) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.`extension` != rhs.`extension` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QuoteElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuoteElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "quoteMessage"),
    3: .same(proto: "messageEntityList"),
  ]

  fileprivate class _StorageClass {
    var _text: String = String()
    var _quoteMessage: IMMessage? = nil
    var _messageEntityList: [MessageEntity] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _text = source._text
      _quoteMessage = source._quoteMessage
      _messageEntityList = source._messageEntityList
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._text) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._quoteMessage) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._messageEntityList) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._text.isEmpty {
        try visitor.visitSingularStringField(value: _storage._text, fieldNumber: 1)
      }
      try { if let v = _storage._quoteMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._messageEntityList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._messageEntityList, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: QuoteElem, rhs: QuoteElem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._text != rhs_storage._text {return false}
        if _storage._quoteMessage != rhs_storage._quoteMessage {return false}
        if _storage._messageEntityList != rhs_storage._messageEntityList {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AdvancedTextElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdvancedTextElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "messageEntityList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.messageEntityList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.messageEntityList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messageEntityList, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AdvancedTextElem, rhs: AdvancedTextElem) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.messageEntityList != rhs.messageEntityList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TypingElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TypingElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msgTips"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgTips) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgTips.isEmpty {
      try visitor.visitSingularStringField(value: self.msgTips, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TypingElem, rhs: TypingElem) -> Bool {
    if lhs.msgTips != rhs.msgTips {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StreamElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "content"),
    3: .same(proto: "packets"),
    4: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.packets) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    if !self.packets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.packets, fieldNumber: 3)
    }
    if self.end != false {
      try visitor.visitSingularBoolField(value: self.end, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StreamElem, rhs: StreamElem) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.content != rhs.content {return false}
    if lhs.packets != rhs.packets {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UploadProgress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadProgress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "save"),
    3: .same(proto: "current"),
    4: .same(proto: "uploadID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.save) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.current) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uploadID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt64Field(value: self.total, fieldNumber: 1)
    }
    if self.save != 0 {
      try visitor.visitSingularInt64Field(value: self.save, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt64Field(value: self.current, fieldNumber: 3)
    }
    if !self.uploadID.isEmpty {
      try visitor.visitSingularStringField(value: self.uploadID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UploadProgress, rhs: UploadProgress) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.save != rhs.save {return false}
    if lhs.current != rhs.current {return false}
    if lhs.uploadID != rhs.uploadID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AttachedInfoElem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttachedInfoElem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isPrivateChat"),
    2: .same(proto: "burnDuration"),
    3: .same(proto: "hasReadTime"),
    4: .same(proto: "progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isPrivateChat) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.burnDuration) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.hasReadTime_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._progress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.isPrivateChat != false {
      try visitor.visitSingularBoolField(value: self.isPrivateChat, fieldNumber: 1)
    }
    if self.burnDuration != 0 {
      try visitor.visitSingularInt32Field(value: self.burnDuration, fieldNumber: 2)
    }
    if self.hasReadTime_p != 0 {
      try visitor.visitSingularInt64Field(value: self.hasReadTime_p, fieldNumber: 3)
    }
    try { if let v = self._progress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AttachedInfoElem, rhs: AttachedInfoElem) -> Bool {
    if lhs.isPrivateChat != rhs.isPrivateChat {return false}
    if lhs.burnDuration != rhs.burnDuration {return false}
    if lhs.hasReadTime_p != rhs.hasReadTime_p {return false}
    if lhs._progress != rhs._progress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupCreatedTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupCreatedTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "opUser"),
    3: .same(proto: "memberList"),
    4: .same(proto: "operationTime"),
    5: .same(proto: "groupOwnerUser"),
  ]

  fileprivate class _StorageClass {
    var _group: IMGroup? = nil
    var _opUser: IMGroupMember? = nil
    var _memberList: [IMGroupMember] = []
    var _operationTime: Int64 = 0
    var _groupOwnerUser: IMGroupMember? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _group = source._group
      _opUser = source._opUser
      _memberList = source._memberList
      _operationTime = source._operationTime
      _groupOwnerUser = source._groupOwnerUser
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._opUser) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._memberList) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._operationTime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._groupOwnerUser) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._opUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._memberList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._memberList, fieldNumber: 3)
      }
      if _storage._operationTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._operationTime, fieldNumber: 4)
      }
      try { if let v = _storage._groupOwnerUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GroupCreatedTips, rhs: GroupCreatedTips) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._group != rhs_storage._group {return false}
        if _storage._opUser != rhs_storage._opUser {return false}
        if _storage._memberList != rhs_storage._memberList {return false}
        if _storage._operationTime != rhs_storage._operationTime {return false}
        if _storage._groupOwnerUser != rhs_storage._groupOwnerUser {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MemberQuitTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberQuitTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "quitUser"),
    3: .same(proto: "operationTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._quitUser) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.operationTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._quitUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.operationTime != 0 {
      try visitor.visitSingularInt64Field(value: self.operationTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MemberQuitTips, rhs: MemberQuitTips) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._quitUser != rhs._quitUser {return false}
    if lhs.operationTime != rhs.operationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupOwnerTransferredTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupOwnerTransferredTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "opUser"),
    3: .same(proto: "newGroupOwner"),
    4: .same(proto: "oldGroupOwner"),
    5: .same(proto: "operationTime"),
    6: .same(proto: "oldGroupOwnerInfo"),
  ]

  fileprivate class _StorageClass {
    var _group: IMGroup? = nil
    var _opUser: IMGroupMember? = nil
    var _newGroupOwner: IMGroupMember? = nil
    var _oldGroupOwner: String = String()
    var _operationTime: Int64 = 0
    var _oldGroupOwnerInfo: IMGroupMember? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _group = source._group
      _opUser = source._opUser
      _newGroupOwner = source._newGroupOwner
      _oldGroupOwner = source._oldGroupOwner
      _operationTime = source._operationTime
      _oldGroupOwnerInfo = source._oldGroupOwnerInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._opUser) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._newGroupOwner) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._oldGroupOwner) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._operationTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._oldGroupOwnerInfo) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._opUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._newGroupOwner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._oldGroupOwner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._oldGroupOwner, fieldNumber: 4)
      }
      if _storage._operationTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._operationTime, fieldNumber: 5)
      }
      try { if let v = _storage._oldGroupOwnerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GroupOwnerTransferredTips, rhs: GroupOwnerTransferredTips) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._group != rhs_storage._group {return false}
        if _storage._opUser != rhs_storage._opUser {return false}
        if _storage._newGroupOwner != rhs_storage._newGroupOwner {return false}
        if _storage._oldGroupOwner != rhs_storage._oldGroupOwner {return false}
        if _storage._operationTime != rhs_storage._operationTime {return false}
        if _storage._oldGroupOwnerInfo != rhs_storage._oldGroupOwnerInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MemberKickedTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberKickedTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "opUser"),
    3: .same(proto: "kickedUserList"),
    4: .same(proto: "operationTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._opUser) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.kickedUserList) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.operationTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._opUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.kickedUserList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.kickedUserList, fieldNumber: 3)
    }
    if self.operationTime != 0 {
      try visitor.visitSingularInt64Field(value: self.operationTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MemberKickedTips, rhs: MemberKickedTips) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._opUser != rhs._opUser {return false}
    if lhs.kickedUserList != rhs.kickedUserList {return false}
    if lhs.operationTime != rhs.operationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MemberInvitedTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberInvitedTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "opUser"),
    3: .same(proto: "invitedUserList"),
    4: .same(proto: "operationTime"),
    7: .same(proto: "inviterUser"),
  ]

  fileprivate class _StorageClass {
    var _group: IMGroup? = nil
    var _opUser: IMGroupMember? = nil
    var _invitedUserList: [IMGroupMember] = []
    var _operationTime: Int64 = 0
    var _inviterUser: IMGroupMember? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _group = source._group
      _opUser = source._opUser
      _invitedUserList = source._invitedUserList
      _operationTime = source._operationTime
      _inviterUser = source._inviterUser
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._opUser) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._invitedUserList) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._operationTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._inviterUser) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._opUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._invitedUserList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._invitedUserList, fieldNumber: 3)
      }
      if _storage._operationTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._operationTime, fieldNumber: 4)
      }
      try { if let v = _storage._inviterUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MemberInvitedTips, rhs: MemberInvitedTips) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._group != rhs_storage._group {return false}
        if _storage._opUser != rhs_storage._opUser {return false}
        if _storage._invitedUserList != rhs_storage._invitedUserList {return false}
        if _storage._operationTime != rhs_storage._operationTime {return false}
        if _storage._inviterUser != rhs_storage._inviterUser {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MemberEnterTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberEnterTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "entrantUser"),
    3: .same(proto: "operationTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._entrantUser) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.operationTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._entrantUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.operationTime != 0 {
      try visitor.visitSingularInt64Field(value: self.operationTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MemberEnterTips, rhs: MemberEnterTips) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._entrantUser != rhs._entrantUser {return false}
    if lhs.operationTime != rhs.operationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupDismissedTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupDismissedTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "opUser"),
    3: .same(proto: "operationTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._opUser) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.operationTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._opUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.operationTime != 0 {
      try visitor.visitSingularInt64Field(value: self.operationTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GroupDismissedTips, rhs: GroupDismissedTips) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._opUser != rhs._opUser {return false}
    if lhs.operationTime != rhs.operationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupMemberMutedTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMemberMutedTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "opUser"),
    3: .same(proto: "operationTime"),
    4: .same(proto: "mutedUser"),
    5: .same(proto: "mutedSeconds"),
  ]

  fileprivate class _StorageClass {
    var _group: IMGroup? = nil
    var _opUser: IMGroupMember? = nil
    var _operationTime: Int64 = 0
    var _mutedUser: IMGroupMember? = nil
    var _mutedSeconds: UInt32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _group = source._group
      _opUser = source._opUser
      _operationTime = source._operationTime
      _mutedUser = source._mutedUser
      _mutedSeconds = source._mutedSeconds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._opUser) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._operationTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._mutedUser) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._mutedSeconds) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._opUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._operationTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._operationTime, fieldNumber: 3)
      }
      try { if let v = _storage._mutedUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._mutedSeconds != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._mutedSeconds, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GroupMemberMutedTips, rhs: GroupMemberMutedTips) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._group != rhs_storage._group {return false}
        if _storage._opUser != rhs_storage._opUser {return false}
        if _storage._operationTime != rhs_storage._operationTime {return false}
        if _storage._mutedUser != rhs_storage._mutedUser {return false}
        if _storage._mutedSeconds != rhs_storage._mutedSeconds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupMemberCancelMutedTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMemberCancelMutedTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "opUser"),
    3: .same(proto: "operationTime"),
    4: .same(proto: "mutedUser"),
  ]

  fileprivate class _StorageClass {
    var _group: IMGroup? = nil
    var _opUser: IMGroupMember? = nil
    var _operationTime: Int64 = 0
    var _mutedUser: IMGroupMember? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _group = source._group
      _opUser = source._opUser
      _operationTime = source._operationTime
      _mutedUser = source._mutedUser
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._opUser) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._operationTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._mutedUser) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._opUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._operationTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._operationTime, fieldNumber: 3)
      }
      try { if let v = _storage._mutedUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GroupMemberCancelMutedTips, rhs: GroupMemberCancelMutedTips) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._group != rhs_storage._group {return false}
        if _storage._opUser != rhs_storage._opUser {return false}
        if _storage._operationTime != rhs_storage._operationTime {return false}
        if _storage._mutedUser != rhs_storage._mutedUser {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupMutedTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMutedTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "opUser"),
    3: .same(proto: "operationTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._opUser) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.operationTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._opUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.operationTime != 0 {
      try visitor.visitSingularInt64Field(value: self.operationTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GroupMutedTips, rhs: GroupMutedTips) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._opUser != rhs._opUser {return false}
    if lhs.operationTime != rhs.operationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupCancelMutedTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupCancelMutedTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "opUser"),
    3: .same(proto: "operationTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._opUser) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.operationTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._opUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.operationTime != 0 {
      try visitor.visitSingularInt64Field(value: self.operationTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GroupCancelMutedTips, rhs: GroupCancelMutedTips) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._opUser != rhs._opUser {return false}
    if lhs.operationTime != rhs.operationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FromToUserID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FromToUserID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fromUserID"),
    2: .same(proto: "toUserID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fromUserID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.toUserID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fromUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.fromUserID, fieldNumber: 1)
    }
    if !self.toUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.toUserID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FromToUserID, rhs: FromToUserID) -> Bool {
    if lhs.fromUserID != rhs.fromUserID {return false}
    if lhs.toUserID != rhs.toUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FriendApplicationApprovedTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FriendApplicationApprovedTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fromToUserID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fromToUserID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fromToUserID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FriendApplicationApprovedTips, rhs: FriendApplicationApprovedTips) -> Bool {
    if lhs._fromToUserID != rhs._fromToUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RevokedTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokedTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "revokerID"),
    2: .same(proto: "revokerRole"),
    3: .same(proto: "clientMsgID"),
    4: .same(proto: "revokerNickname"),
    5: .same(proto: "revokeTime"),
    6: .same(proto: "sourceMessageSendTime"),
    7: .same(proto: "sourceMessageSendID"),
    8: .same(proto: "sourceMessageSenderNickname"),
    10: .same(proto: "sessionType"),
    11: .same(proto: "seq"),
    12: .same(proto: "ex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.revokerID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.revokerRole) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clientMsgID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.revokerNickname) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.revokeTime) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.sourceMessageSendTime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.sourceMessageSendID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.sourceMessageSenderNickname) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.sessionType) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.seq) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.ex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.revokerID.isEmpty {
      try visitor.visitSingularStringField(value: self.revokerID, fieldNumber: 1)
    }
    if self.revokerRole != 0 {
      try visitor.visitSingularInt32Field(value: self.revokerRole, fieldNumber: 2)
    }
    if !self.clientMsgID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientMsgID, fieldNumber: 3)
    }
    if !self.revokerNickname.isEmpty {
      try visitor.visitSingularStringField(value: self.revokerNickname, fieldNumber: 4)
    }
    if self.revokeTime != 0 {
      try visitor.visitSingularInt64Field(value: self.revokeTime, fieldNumber: 5)
    }
    if self.sourceMessageSendTime != 0 {
      try visitor.visitSingularInt64Field(value: self.sourceMessageSendTime, fieldNumber: 6)
    }
    if !self.sourceMessageSendID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceMessageSendID, fieldNumber: 7)
    }
    if !self.sourceMessageSenderNickname.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceMessageSenderNickname, fieldNumber: 8)
    }
    if self.sessionType != 0 {
      try visitor.visitSingularInt32Field(value: self.sessionType, fieldNumber: 10)
    }
    if self.seq != 0 {
      try visitor.visitSingularInt64Field(value: self.seq, fieldNumber: 11)
    }
    if !self.ex.isEmpty {
      try visitor.visitSingularStringField(value: self.ex, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RevokedTips, rhs: RevokedTips) -> Bool {
    if lhs.revokerID != rhs.revokerID {return false}
    if lhs.revokerRole != rhs.revokerRole {return false}
    if lhs.clientMsgID != rhs.clientMsgID {return false}
    if lhs.revokerNickname != rhs.revokerNickname {return false}
    if lhs.revokeTime != rhs.revokeTime {return false}
    if lhs.sourceMessageSendTime != rhs.sourceMessageSendTime {return false}
    if lhs.sourceMessageSendID != rhs.sourceMessageSendID {return false}
    if lhs.sourceMessageSenderNickname != rhs.sourceMessageSenderNickname {return false}
    if lhs.sessionType != rhs.sessionType {return false}
    if lhs.seq != rhs.seq {return false}
    if lhs.ex != rhs.ex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConversationPrivateChatTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConversationPrivateChatTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recvID"),
    2: .same(proto: "sendID"),
    3: .same(proto: "isPrivate"),
    4: .same(proto: "conversationID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recvID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sendID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isPrivate) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recvID.isEmpty {
      try visitor.visitSingularStringField(value: self.recvID, fieldNumber: 1)
    }
    if !self.sendID.isEmpty {
      try visitor.visitSingularStringField(value: self.sendID, fieldNumber: 2)
    }
    if self.isPrivate != false {
      try visitor.visitSingularBoolField(value: self.isPrivate, fieldNumber: 3)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConversationPrivateChatTips, rhs: ConversationPrivateChatTips) -> Bool {
    if lhs.recvID != rhs.recvID {return false}
    if lhs.sendID != rhs.sendID {return false}
    if lhs.isPrivate != rhs.isPrivate {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BusinessTips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BusinessTips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BusinessTips, rhs: BusinessTips) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IMMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientMsgID"),
    2: .same(proto: "serverMsgID"),
    3: .same(proto: "createTime"),
    4: .same(proto: "sendTime"),
    5: .same(proto: "sessionType"),
    6: .same(proto: "sendID"),
    7: .same(proto: "recvID"),
    8: .same(proto: "msgFrom"),
    9: .same(proto: "contentType"),
    10: .same(proto: "senderPlatformID"),
    11: .same(proto: "senderNickname"),
    12: .same(proto: "senderFaceURL"),
    13: .same(proto: "groupID"),
    15: .same(proto: "seq"),
    16: .same(proto: "isRead"),
    17: .same(proto: "status"),
    18: .same(proto: "offlinePush"),
    20: .same(proto: "ex"),
    21: .same(proto: "localEx"),
    22: .same(proto: "attachedInfoElem"),
    23: .same(proto: "textElem"),
    24: .same(proto: "cardElem"),
    25: .same(proto: "pictureElem"),
    26: .same(proto: "soundElem"),
    27: .same(proto: "videoElem"),
    28: .same(proto: "fileElem"),
    29: .same(proto: "mergeElem"),
    30: .same(proto: "atTextElem"),
    31: .same(proto: "faceElem"),
    32: .same(proto: "locationElem"),
    33: .same(proto: "customElem"),
    34: .same(proto: "quoteElem"),
    35: .same(proto: "advancedTextElem"),
    36: .same(proto: "typingElem"),
    37: .same(proto: "streamElem"),
    38: .same(proto: "revokedTips"),
    311: .same(proto: "groupCreatedTips"),
    43: .same(proto: "memberQuitTips"),
    46: .same(proto: "groupOwnerTransferredTips"),
    47: .same(proto: "memberKickedTips"),
    48: .same(proto: "memberInvitedTips"),
    49: .same(proto: "memberEnterTips"),
    50: .same(proto: "groupDismissedTips"),
    51: .same(proto: "groupMemberMutedTips"),
    52: .same(proto: "groupMemberCancelMutedTips"),
    53: .same(proto: "groupMutedTips"),
    54: .same(proto: "groupCancelMutedTips"),
    57: .same(proto: "friendApplicationApprovedTips"),
    79: .same(proto: "conversationPrivateChatTips"),
    80: .same(proto: "businessTips"),
  ]

  fileprivate class _StorageClass {
    var _clientMsgID: String = String()
    var _serverMsgID: String = String()
    var _createTime: Int64 = 0
    var _sendTime: Int64 = 0
    var _sessionType: SessionType = .sessionType_
    var _sendID: String = String()
    var _recvID: String = String()
    var _msgFrom: MsgFrom = .msgFrom_
    var _contentType: ContentType = .contentType_
    var _senderPlatformID: Platform = .platform_
    var _senderNickname: String = String()
    var _senderFaceURL: String = String()
    var _groupID: String = String()
    var _seq: Int64 = 0
    var _isRead: Bool = false
    var _status: MsgStatus = .msgStatus_
    var _offlinePush: OfflinePushInfo? = nil
    var _ex: String = String()
    var _localEx: String = String()
    var _attachedInfoElem: AttachedInfoElem? = nil
    var _content: IMMessage.OneOf_Content?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _clientMsgID = source._clientMsgID
      _serverMsgID = source._serverMsgID
      _createTime = source._createTime
      _sendTime = source._sendTime
      _sessionType = source._sessionType
      _sendID = source._sendID
      _recvID = source._recvID
      _msgFrom = source._msgFrom
      _contentType = source._contentType
      _senderPlatformID = source._senderPlatformID
      _senderNickname = source._senderNickname
      _senderFaceURL = source._senderFaceURL
      _groupID = source._groupID
      _seq = source._seq
      _isRead = source._isRead
      _status = source._status
      _offlinePush = source._offlinePush
      _ex = source._ex
      _localEx = source._localEx
      _attachedInfoElem = source._attachedInfoElem
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._clientMsgID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._serverMsgID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._createTime) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._sendTime) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._sessionType) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._sendID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._recvID) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._msgFrom) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._contentType) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._senderPlatformID) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._senderNickname) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._senderFaceURL) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._groupID) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._seq) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._isRead) }()
        case 17: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._offlinePush) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._ex) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._localEx) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._attachedInfoElem) }()
        case 23: try {
          var v: TextElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .textElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .textElem(v)
          }
        }()
        case 24: try {
          var v: CardElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .cardElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .cardElem(v)
          }
        }()
        case 25: try {
          var v: PictureElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .pictureElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .pictureElem(v)
          }
        }()
        case 26: try {
          var v: SoundElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .soundElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .soundElem(v)
          }
        }()
        case 27: try {
          var v: VideoElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .videoElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .videoElem(v)
          }
        }()
        case 28: try {
          var v: FileElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .fileElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .fileElem(v)
          }
        }()
        case 29: try {
          var v: MergeElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .mergeElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .mergeElem(v)
          }
        }()
        case 30: try {
          var v: AtTextElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .atTextElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .atTextElem(v)
          }
        }()
        case 31: try {
          var v: FaceElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .faceElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .faceElem(v)
          }
        }()
        case 32: try {
          var v: LocationElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .locationElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .locationElem(v)
          }
        }()
        case 33: try {
          var v: CustomElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .customElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .customElem(v)
          }
        }()
        case 34: try {
          var v: QuoteElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .quoteElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .quoteElem(v)
          }
        }()
        case 35: try {
          var v: AdvancedTextElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .advancedTextElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .advancedTextElem(v)
          }
        }()
        case 36: try {
          var v: TypingElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .typingElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .typingElem(v)
          }
        }()
        case 37: try {
          var v: StreamElem?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .streamElem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .streamElem(v)
          }
        }()
        case 38: try {
          var v: RevokedTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .revokedTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .revokedTips(v)
          }
        }()
        case 43: try {
          var v: MemberQuitTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .memberQuitTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .memberQuitTips(v)
          }
        }()
        case 46: try {
          var v: GroupOwnerTransferredTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .groupOwnerTransferredTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .groupOwnerTransferredTips(v)
          }
        }()
        case 47: try {
          var v: MemberKickedTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .memberKickedTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .memberKickedTips(v)
          }
        }()
        case 48: try {
          var v: MemberInvitedTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .memberInvitedTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .memberInvitedTips(v)
          }
        }()
        case 49: try {
          var v: MemberEnterTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .memberEnterTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .memberEnterTips(v)
          }
        }()
        case 50: try {
          var v: GroupDismissedTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .groupDismissedTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .groupDismissedTips(v)
          }
        }()
        case 51: try {
          var v: GroupMemberMutedTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .groupMemberMutedTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .groupMemberMutedTips(v)
          }
        }()
        case 52: try {
          var v: GroupMemberCancelMutedTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .groupMemberCancelMutedTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .groupMemberCancelMutedTips(v)
          }
        }()
        case 53: try {
          var v: GroupMutedTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .groupMutedTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .groupMutedTips(v)
          }
        }()
        case 54: try {
          var v: GroupCancelMutedTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .groupCancelMutedTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .groupCancelMutedTips(v)
          }
        }()
        case 57: try {
          var v: FriendApplicationApprovedTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .friendApplicationApprovedTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .friendApplicationApprovedTips(v)
          }
        }()
        case 79: try {
          var v: ConversationPrivateChatTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .conversationPrivateChatTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .conversationPrivateChatTips(v)
          }
        }()
        case 80: try {
          var v: BusinessTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .businessTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .businessTips(v)
          }
        }()
        case 311: try {
          var v: GroupCreatedTips?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .groupCreatedTips(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .groupCreatedTips(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._clientMsgID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientMsgID, fieldNumber: 1)
      }
      if !_storage._serverMsgID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serverMsgID, fieldNumber: 2)
      }
      if _storage._createTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createTime, fieldNumber: 3)
      }
      if _storage._sendTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._sendTime, fieldNumber: 4)
      }
      if _storage._sessionType != .sessionType_ {
        try visitor.visitSingularEnumField(value: _storage._sessionType, fieldNumber: 5)
      }
      if !_storage._sendID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sendID, fieldNumber: 6)
      }
      if !_storage._recvID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._recvID, fieldNumber: 7)
      }
      if _storage._msgFrom != .msgFrom_ {
        try visitor.visitSingularEnumField(value: _storage._msgFrom, fieldNumber: 8)
      }
      if _storage._contentType != .contentType_ {
        try visitor.visitSingularEnumField(value: _storage._contentType, fieldNumber: 9)
      }
      if _storage._senderPlatformID != .platform_ {
        try visitor.visitSingularEnumField(value: _storage._senderPlatformID, fieldNumber: 10)
      }
      if !_storage._senderNickname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderNickname, fieldNumber: 11)
      }
      if !_storage._senderFaceURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderFaceURL, fieldNumber: 12)
      }
      if !_storage._groupID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupID, fieldNumber: 13)
      }
      if _storage._seq != 0 {
        try visitor.visitSingularInt64Field(value: _storage._seq, fieldNumber: 15)
      }
      if _storage._isRead != false {
        try visitor.visitSingularBoolField(value: _storage._isRead, fieldNumber: 16)
      }
      if _storage._status != .msgStatus_ {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 17)
      }
      try { if let v = _storage._offlinePush {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if !_storage._ex.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ex, fieldNumber: 20)
      }
      if !_storage._localEx.isEmpty {
        try visitor.visitSingularStringField(value: _storage._localEx, fieldNumber: 21)
      }
      try { if let v = _storage._attachedInfoElem {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      switch _storage._content {
      case .textElem?: try {
        guard case .textElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .cardElem?: try {
        guard case .cardElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .pictureElem?: try {
        guard case .pictureElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .soundElem?: try {
        guard case .soundElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .videoElem?: try {
        guard case .videoElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .fileElem?: try {
        guard case .fileElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      case .mergeElem?: try {
        guard case .mergeElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }()
      case .atTextElem?: try {
        guard case .atTextElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }()
      case .faceElem?: try {
        guard case .faceElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }()
      case .locationElem?: try {
        guard case .locationElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }()
      case .customElem?: try {
        guard case .customElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }()
      case .quoteElem?: try {
        guard case .quoteElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }()
      case .advancedTextElem?: try {
        guard case .advancedTextElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }()
      case .typingElem?: try {
        guard case .typingElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }()
      case .streamElem?: try {
        guard case .streamElem(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }()
      case .revokedTips?: try {
        guard case .revokedTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }()
      case .memberQuitTips?: try {
        guard case .memberQuitTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }()
      case .groupOwnerTransferredTips?: try {
        guard case .groupOwnerTransferredTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      }()
      case .memberKickedTips?: try {
        guard case .memberKickedTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      }()
      case .memberInvitedTips?: try {
        guard case .memberInvitedTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      }()
      case .memberEnterTips?: try {
        guard case .memberEnterTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      }()
      case .groupDismissedTips?: try {
        guard case .groupDismissedTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }()
      case .groupMemberMutedTips?: try {
        guard case .groupMemberMutedTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case .groupMemberCancelMutedTips?: try {
        guard case .groupMemberCancelMutedTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }()
      case .groupMutedTips?: try {
        guard case .groupMutedTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      }()
      case .groupCancelMutedTips?: try {
        guard case .groupCancelMutedTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      }()
      case .friendApplicationApprovedTips?: try {
        guard case .friendApplicationApprovedTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      }()
      case .conversationPrivateChatTips?: try {
        guard case .conversationPrivateChatTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 79)
      }()
      case .businessTips?: try {
        guard case .businessTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
      }()
      case .groupCreatedTips?: try {
        guard case .groupCreatedTips(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 311)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMMessage, rhs: IMMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._clientMsgID != rhs_storage._clientMsgID {return false}
        if _storage._serverMsgID != rhs_storage._serverMsgID {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._sendTime != rhs_storage._sendTime {return false}
        if _storage._sessionType != rhs_storage._sessionType {return false}
        if _storage._sendID != rhs_storage._sendID {return false}
        if _storage._recvID != rhs_storage._recvID {return false}
        if _storage._msgFrom != rhs_storage._msgFrom {return false}
        if _storage._contentType != rhs_storage._contentType {return false}
        if _storage._senderPlatformID != rhs_storage._senderPlatformID {return false}
        if _storage._senderNickname != rhs_storage._senderNickname {return false}
        if _storage._senderFaceURL != rhs_storage._senderFaceURL {return false}
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._seq != rhs_storage._seq {return false}
        if _storage._isRead != rhs_storage._isRead {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._offlinePush != rhs_storage._offlinePush {return false}
        if _storage._ex != rhs_storage._ex {return false}
        if _storage._localEx != rhs_storage._localEx {return false}
        if _storage._attachedInfoElem != rhs_storage._attachedInfoElem {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
