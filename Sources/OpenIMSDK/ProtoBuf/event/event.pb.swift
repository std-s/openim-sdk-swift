// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum FuncRequestEventName: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case none // = 0
  case initSdk // = 1
  case login // = 2
  case logout // = 3
  case setAppBackgroundStatus // = 107
  case networkStatusChanged // = 108
  case getLoginStatus // = 109
  case version // = 110
  case sendMessage // = 4
  case uploadLogs // = 5
  case uploadFile // = 6
  case log // = 7
  case updateFcmToken // = 10
  case setAppBadge // = 11
  case eventOnSendMsgProgress // = 12
  case eventOnUploadFileProgress // = 13
  case eventOnUploadLogsProgress // = 14
  case eventOnConnecting // = 15
  case eventOnConnectSuccess // = 16
  case eventOnConnectFailed // = 17
  case eventOnKickedOffline // = 18
  case eventOnUserTokenExpired // = 19
  case eventOnUserTokenInvalid // = 20
  case eventOnSyncServerStart // = 21
  case eventOnSyncServerFinish // = 22
  case eventOnSyncServerFailed // = 23
  case eventOnSyncServerProgress // = 24
  case eventOnNewConversation // = 25
  case eventOnConversationChanged // = 26
  case eventOnTotalUnreadMessageCountChanged // = 27
  case eventOnConversationUserInputStatusChanged // = 28
  case eventOnRecvNewMessage // = 29
  case eventOnRecvC2CreadReceipt // = 30
  case eventOnNewRecvMessageRevoked // = 31
  case eventOnRecvOfflineNewMessage // = 32
  case eventOnMessageDeleted // = 33
  case eventOnRecvOnlineOnlyMessage // = 34
  case eventOnMessageEdited // = 35

  /// FriendCallback Events
  case eventOnFriendApplicationAdded // = 36
  case eventOnFriendApplicationDeleted // = 37
  case eventOnFriendApplicationAccepted // = 38
  case eventOnFriendApplicationRejected // = 39
  case eventOnFriendAdded // = 40
  case eventOnFriendDeleted // = 41
  case eventOnFriendInfoChanged // = 42
  case eventOnBlackAdded // = 43
  case eventOnBlackDeleted // = 44

  /// GroupCallback Events
  case eventOnJoinedGroupAdded // = 45
  case eventOnJoinedGroupDeleted // = 46
  case eventOnGroupMemberAdded // = 47
  case eventOnGroupMemberDeleted // = 48
  case eventOnGroupApplicationAdded // = 49
  case eventOnGroupApplicationDeleted // = 50
  case eventOnGroupInfoChanged // = 51
  case eventOnGroupDismissed // = 52
  case eventOnGroupMemberInfoChanged // = 53
  case eventOnGroupApplicationAccepted // = 54
  case eventOnGroupApplicationRejected // = 55

  /// CustomBusinessCallback Events
  case eventOnRecvCustomBusinessMessage // = 56

  /// UserCallback Events
  case eventOnSelfInfoUpdated // = 57
  case eventOnUserStatusChanged // = 58
  case eventOnUserCommandAdd // = 59
  case eventOnUserCommandDelete // = 60
  case eventOnUserCommandUpdate // = 61
  case createGroup // = 1000
  case joinGroup // = 1001
  case quitGroup // = 1002
  case dismissGroup // = 1003
  case changeGroupMute // = 1004
  case changeGroupMemberMute // = 1005
  case transferGroupOwner // = 1006
  case kickGroupMember // = 1007
  case setGroupInfo // = 1008
  case setGroupMemberInfo // = 1009
  case getJoinedGroups // = 1010
  case getJoinedGroupsPage // = 1011
  case getSpecifiedGroupsInfo // = 1012
  case searchGroups // = 1013
  case getGroupMemberOwnerAndAdmin // = 1014
  case getGroupMembersByJoinTimeFilter // = 1015
  case getSpecifiedGroupMembersInfo // = 1016
  case getGroupMembers // = 1017
  case getGroupRequest // = 1018
  case searchGroupMembers // = 1019
  case isJoinGroup // = 1020
  case getUsersInGroup // = 1021
  case inviteUserToGroup // = 1022
  case handlerGroupRequest // = 1023
  case getSpecifiedFriends // = 1100
  case addFriend // = 1101
  case getFriendRequests // = 1102
  case handlerFriendRequest // = 1103
  case checkFriend // = 1104
  case deleteFriend // = 1105
  case getFriends // = 1106
  case getFriendsPage // = 1107
  case searchFriends // = 1108
  case addBlack // = 1109
  case deleteBlack // = 1110
  case getBlacks // = 1111
  case updateFriends // = 1112

  /// conversation_msg
  case getAllConversationList // = 2000
  case getConversationListSplit // = 2001
  case hideConversation // = 2002
  case getAtAllTag // = 2003
  case getOneConversation // = 2004
  case getMultipleConversation // = 2005
  case hideAllConversations // = 2006
  case setConversationDraft // = 2007
  case setConversation // = 2008
  case getTotalUnreadMsgCount // = 2009
  case getConversationIdbySessionType // = 2010
  case findMessageList // = 2011
  case getAdvancedHistoryMessageList // = 2012
  case getAdvancedHistoryMessageListReverse // = 2013
  case revokeMessage // = 2014
  case typingStatusUpdate // = 2015
  case markConversationMessageAsRead // = 2016
  case markAllConversationMessageAsRead // = 2017
  case deleteMessageFromLocalStorage // = 2018
  case deleteMessage // = 2019
  case deleteAllMsgFromLocalAndServer // = 2020
  case deleteAllMessageFromLocalStorage // = 2021
  case clearConversationAndDeleteAllMsg // = 2022
  case deleteConversationAndDeleteAllMsg // = 2023
  case insertSingleMessageToLocalStorage // = 2024
  case insertGroupMessageToLocalStorage // = 2025
  case searchLocalMessages // = 2026
  case setMessageLocalEx // = 2027
  case searchConversation // = 2028
  case createTextMessage // = 2029
  case createAdvancedTextMessage // = 2030
  case createTextAtMessage // = 2031
  case createLocationMessage // = 2032
  case createCustomMessage // = 2033
  case createQuoteMessage // = 2034
  case createAdvancedQuoteMessage // = 2035
  case createCardMessage // = 2036
  case createImageMessage // = 2037
  case createSoundMessage // = 2038
  case createVideoMessage // = 2039
  case createFileMessage // = 2040
  case createMergerMessage // = 2041
  case createFaceMessage // = 2042
  case createForwardMessage // = 2043
  case processUserCommandGetAll // = 2100
  case getSelfUserInfo // = 2101
  case setSelfInfo // = 2102
  case processUserCommandAdd // = 2103
  case processUserCommandDelete // = 2104
  case processUserCommandUpdate // = 2105
  case getUsersInfo // = 2106
  case subscribeUsersOnlineStatus // = 2229
  case unsubscribeUsersOnlineStatus // = 2230

  /// The following functions are only used for Go and JS interaction and can be ignored by other platforms.
  case jsFileOpen // = 2110
  case jsFileRead // = 2111
  case jsFileClose // = 2112
  case jsSqliteOpen // = 2113
  case jsSqliteExec // = 2114
  case jsSqliteQuery // = 2115
  case jsSqliteClose // = 2116
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .initSdk
    case 2: self = .login
    case 3: self = .logout
    case 4: self = .sendMessage
    case 5: self = .uploadLogs
    case 6: self = .uploadFile
    case 7: self = .log
    case 10: self = .updateFcmToken
    case 11: self = .setAppBadge
    case 12: self = .eventOnSendMsgProgress
    case 13: self = .eventOnUploadFileProgress
    case 14: self = .eventOnUploadLogsProgress
    case 15: self = .eventOnConnecting
    case 16: self = .eventOnConnectSuccess
    case 17: self = .eventOnConnectFailed
    case 18: self = .eventOnKickedOffline
    case 19: self = .eventOnUserTokenExpired
    case 20: self = .eventOnUserTokenInvalid
    case 21: self = .eventOnSyncServerStart
    case 22: self = .eventOnSyncServerFinish
    case 23: self = .eventOnSyncServerFailed
    case 24: self = .eventOnSyncServerProgress
    case 25: self = .eventOnNewConversation
    case 26: self = .eventOnConversationChanged
    case 27: self = .eventOnTotalUnreadMessageCountChanged
    case 28: self = .eventOnConversationUserInputStatusChanged
    case 29: self = .eventOnRecvNewMessage
    case 30: self = .eventOnRecvC2CreadReceipt
    case 31: self = .eventOnNewRecvMessageRevoked
    case 32: self = .eventOnRecvOfflineNewMessage
    case 33: self = .eventOnMessageDeleted
    case 34: self = .eventOnRecvOnlineOnlyMessage
    case 35: self = .eventOnMessageEdited
    case 36: self = .eventOnFriendApplicationAdded
    case 37: self = .eventOnFriendApplicationDeleted
    case 38: self = .eventOnFriendApplicationAccepted
    case 39: self = .eventOnFriendApplicationRejected
    case 40: self = .eventOnFriendAdded
    case 41: self = .eventOnFriendDeleted
    case 42: self = .eventOnFriendInfoChanged
    case 43: self = .eventOnBlackAdded
    case 44: self = .eventOnBlackDeleted
    case 45: self = .eventOnJoinedGroupAdded
    case 46: self = .eventOnJoinedGroupDeleted
    case 47: self = .eventOnGroupMemberAdded
    case 48: self = .eventOnGroupMemberDeleted
    case 49: self = .eventOnGroupApplicationAdded
    case 50: self = .eventOnGroupApplicationDeleted
    case 51: self = .eventOnGroupInfoChanged
    case 52: self = .eventOnGroupDismissed
    case 53: self = .eventOnGroupMemberInfoChanged
    case 54: self = .eventOnGroupApplicationAccepted
    case 55: self = .eventOnGroupApplicationRejected
    case 56: self = .eventOnRecvCustomBusinessMessage
    case 57: self = .eventOnSelfInfoUpdated
    case 58: self = .eventOnUserStatusChanged
    case 59: self = .eventOnUserCommandAdd
    case 60: self = .eventOnUserCommandDelete
    case 61: self = .eventOnUserCommandUpdate
    case 107: self = .setAppBackgroundStatus
    case 108: self = .networkStatusChanged
    case 109: self = .getLoginStatus
    case 110: self = .version
    case 1000: self = .createGroup
    case 1001: self = .joinGroup
    case 1002: self = .quitGroup
    case 1003: self = .dismissGroup
    case 1004: self = .changeGroupMute
    case 1005: self = .changeGroupMemberMute
    case 1006: self = .transferGroupOwner
    case 1007: self = .kickGroupMember
    case 1008: self = .setGroupInfo
    case 1009: self = .setGroupMemberInfo
    case 1010: self = .getJoinedGroups
    case 1011: self = .getJoinedGroupsPage
    case 1012: self = .getSpecifiedGroupsInfo
    case 1013: self = .searchGroups
    case 1014: self = .getGroupMemberOwnerAndAdmin
    case 1015: self = .getGroupMembersByJoinTimeFilter
    case 1016: self = .getSpecifiedGroupMembersInfo
    case 1017: self = .getGroupMembers
    case 1018: self = .getGroupRequest
    case 1019: self = .searchGroupMembers
    case 1020: self = .isJoinGroup
    case 1021: self = .getUsersInGroup
    case 1022: self = .inviteUserToGroup
    case 1023: self = .handlerGroupRequest
    case 1100: self = .getSpecifiedFriends
    case 1101: self = .addFriend
    case 1102: self = .getFriendRequests
    case 1103: self = .handlerFriendRequest
    case 1104: self = .checkFriend
    case 1105: self = .deleteFriend
    case 1106: self = .getFriends
    case 1107: self = .getFriendsPage
    case 1108: self = .searchFriends
    case 1109: self = .addBlack
    case 1110: self = .deleteBlack
    case 1111: self = .getBlacks
    case 1112: self = .updateFriends
    case 2000: self = .getAllConversationList
    case 2001: self = .getConversationListSplit
    case 2002: self = .hideConversation
    case 2003: self = .getAtAllTag
    case 2004: self = .getOneConversation
    case 2005: self = .getMultipleConversation
    case 2006: self = .hideAllConversations
    case 2007: self = .setConversationDraft
    case 2008: self = .setConversation
    case 2009: self = .getTotalUnreadMsgCount
    case 2010: self = .getConversationIdbySessionType
    case 2011: self = .findMessageList
    case 2012: self = .getAdvancedHistoryMessageList
    case 2013: self = .getAdvancedHistoryMessageListReverse
    case 2014: self = .revokeMessage
    case 2015: self = .typingStatusUpdate
    case 2016: self = .markConversationMessageAsRead
    case 2017: self = .markAllConversationMessageAsRead
    case 2018: self = .deleteMessageFromLocalStorage
    case 2019: self = .deleteMessage
    case 2020: self = .deleteAllMsgFromLocalAndServer
    case 2021: self = .deleteAllMessageFromLocalStorage
    case 2022: self = .clearConversationAndDeleteAllMsg
    case 2023: self = .deleteConversationAndDeleteAllMsg
    case 2024: self = .insertSingleMessageToLocalStorage
    case 2025: self = .insertGroupMessageToLocalStorage
    case 2026: self = .searchLocalMessages
    case 2027: self = .setMessageLocalEx
    case 2028: self = .searchConversation
    case 2029: self = .createTextMessage
    case 2030: self = .createAdvancedTextMessage
    case 2031: self = .createTextAtMessage
    case 2032: self = .createLocationMessage
    case 2033: self = .createCustomMessage
    case 2034: self = .createQuoteMessage
    case 2035: self = .createAdvancedQuoteMessage
    case 2036: self = .createCardMessage
    case 2037: self = .createImageMessage
    case 2038: self = .createSoundMessage
    case 2039: self = .createVideoMessage
    case 2040: self = .createFileMessage
    case 2041: self = .createMergerMessage
    case 2042: self = .createFaceMessage
    case 2043: self = .createForwardMessage
    case 2100: self = .processUserCommandGetAll
    case 2101: self = .getSelfUserInfo
    case 2102: self = .setSelfInfo
    case 2103: self = .processUserCommandAdd
    case 2104: self = .processUserCommandDelete
    case 2105: self = .processUserCommandUpdate
    case 2106: self = .getUsersInfo
    case 2110: self = .jsFileOpen
    case 2111: self = .jsFileRead
    case 2112: self = .jsFileClose
    case 2113: self = .jsSqliteOpen
    case 2114: self = .jsSqliteExec
    case 2115: self = .jsSqliteQuery
    case 2116: self = .jsSqliteClose
    case 2229: self = .subscribeUsersOnlineStatus
    case 2230: self = .unsubscribeUsersOnlineStatus
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .initSdk: return 1
    case .login: return 2
    case .logout: return 3
    case .sendMessage: return 4
    case .uploadLogs: return 5
    case .uploadFile: return 6
    case .log: return 7
    case .updateFcmToken: return 10
    case .setAppBadge: return 11
    case .eventOnSendMsgProgress: return 12
    case .eventOnUploadFileProgress: return 13
    case .eventOnUploadLogsProgress: return 14
    case .eventOnConnecting: return 15
    case .eventOnConnectSuccess: return 16
    case .eventOnConnectFailed: return 17
    case .eventOnKickedOffline: return 18
    case .eventOnUserTokenExpired: return 19
    case .eventOnUserTokenInvalid: return 20
    case .eventOnSyncServerStart: return 21
    case .eventOnSyncServerFinish: return 22
    case .eventOnSyncServerFailed: return 23
    case .eventOnSyncServerProgress: return 24
    case .eventOnNewConversation: return 25
    case .eventOnConversationChanged: return 26
    case .eventOnTotalUnreadMessageCountChanged: return 27
    case .eventOnConversationUserInputStatusChanged: return 28
    case .eventOnRecvNewMessage: return 29
    case .eventOnRecvC2CreadReceipt: return 30
    case .eventOnNewRecvMessageRevoked: return 31
    case .eventOnRecvOfflineNewMessage: return 32
    case .eventOnMessageDeleted: return 33
    case .eventOnRecvOnlineOnlyMessage: return 34
    case .eventOnMessageEdited: return 35
    case .eventOnFriendApplicationAdded: return 36
    case .eventOnFriendApplicationDeleted: return 37
    case .eventOnFriendApplicationAccepted: return 38
    case .eventOnFriendApplicationRejected: return 39
    case .eventOnFriendAdded: return 40
    case .eventOnFriendDeleted: return 41
    case .eventOnFriendInfoChanged: return 42
    case .eventOnBlackAdded: return 43
    case .eventOnBlackDeleted: return 44
    case .eventOnJoinedGroupAdded: return 45
    case .eventOnJoinedGroupDeleted: return 46
    case .eventOnGroupMemberAdded: return 47
    case .eventOnGroupMemberDeleted: return 48
    case .eventOnGroupApplicationAdded: return 49
    case .eventOnGroupApplicationDeleted: return 50
    case .eventOnGroupInfoChanged: return 51
    case .eventOnGroupDismissed: return 52
    case .eventOnGroupMemberInfoChanged: return 53
    case .eventOnGroupApplicationAccepted: return 54
    case .eventOnGroupApplicationRejected: return 55
    case .eventOnRecvCustomBusinessMessage: return 56
    case .eventOnSelfInfoUpdated: return 57
    case .eventOnUserStatusChanged: return 58
    case .eventOnUserCommandAdd: return 59
    case .eventOnUserCommandDelete: return 60
    case .eventOnUserCommandUpdate: return 61
    case .setAppBackgroundStatus: return 107
    case .networkStatusChanged: return 108
    case .getLoginStatus: return 109
    case .version: return 110
    case .createGroup: return 1000
    case .joinGroup: return 1001
    case .quitGroup: return 1002
    case .dismissGroup: return 1003
    case .changeGroupMute: return 1004
    case .changeGroupMemberMute: return 1005
    case .transferGroupOwner: return 1006
    case .kickGroupMember: return 1007
    case .setGroupInfo: return 1008
    case .setGroupMemberInfo: return 1009
    case .getJoinedGroups: return 1010
    case .getJoinedGroupsPage: return 1011
    case .getSpecifiedGroupsInfo: return 1012
    case .searchGroups: return 1013
    case .getGroupMemberOwnerAndAdmin: return 1014
    case .getGroupMembersByJoinTimeFilter: return 1015
    case .getSpecifiedGroupMembersInfo: return 1016
    case .getGroupMembers: return 1017
    case .getGroupRequest: return 1018
    case .searchGroupMembers: return 1019
    case .isJoinGroup: return 1020
    case .getUsersInGroup: return 1021
    case .inviteUserToGroup: return 1022
    case .handlerGroupRequest: return 1023
    case .getSpecifiedFriends: return 1100
    case .addFriend: return 1101
    case .getFriendRequests: return 1102
    case .handlerFriendRequest: return 1103
    case .checkFriend: return 1104
    case .deleteFriend: return 1105
    case .getFriends: return 1106
    case .getFriendsPage: return 1107
    case .searchFriends: return 1108
    case .addBlack: return 1109
    case .deleteBlack: return 1110
    case .getBlacks: return 1111
    case .updateFriends: return 1112
    case .getAllConversationList: return 2000
    case .getConversationListSplit: return 2001
    case .hideConversation: return 2002
    case .getAtAllTag: return 2003
    case .getOneConversation: return 2004
    case .getMultipleConversation: return 2005
    case .hideAllConversations: return 2006
    case .setConversationDraft: return 2007
    case .setConversation: return 2008
    case .getTotalUnreadMsgCount: return 2009
    case .getConversationIdbySessionType: return 2010
    case .findMessageList: return 2011
    case .getAdvancedHistoryMessageList: return 2012
    case .getAdvancedHistoryMessageListReverse: return 2013
    case .revokeMessage: return 2014
    case .typingStatusUpdate: return 2015
    case .markConversationMessageAsRead: return 2016
    case .markAllConversationMessageAsRead: return 2017
    case .deleteMessageFromLocalStorage: return 2018
    case .deleteMessage: return 2019
    case .deleteAllMsgFromLocalAndServer: return 2020
    case .deleteAllMessageFromLocalStorage: return 2021
    case .clearConversationAndDeleteAllMsg: return 2022
    case .deleteConversationAndDeleteAllMsg: return 2023
    case .insertSingleMessageToLocalStorage: return 2024
    case .insertGroupMessageToLocalStorage: return 2025
    case .searchLocalMessages: return 2026
    case .setMessageLocalEx: return 2027
    case .searchConversation: return 2028
    case .createTextMessage: return 2029
    case .createAdvancedTextMessage: return 2030
    case .createTextAtMessage: return 2031
    case .createLocationMessage: return 2032
    case .createCustomMessage: return 2033
    case .createQuoteMessage: return 2034
    case .createAdvancedQuoteMessage: return 2035
    case .createCardMessage: return 2036
    case .createImageMessage: return 2037
    case .createSoundMessage: return 2038
    case .createVideoMessage: return 2039
    case .createFileMessage: return 2040
    case .createMergerMessage: return 2041
    case .createFaceMessage: return 2042
    case .createForwardMessage: return 2043
    case .processUserCommandGetAll: return 2100
    case .getSelfUserInfo: return 2101
    case .setSelfInfo: return 2102
    case .processUserCommandAdd: return 2103
    case .processUserCommandDelete: return 2104
    case .processUserCommandUpdate: return 2105
    case .getUsersInfo: return 2106
    case .jsFileOpen: return 2110
    case .jsFileRead: return 2111
    case .jsFileClose: return 2112
    case .jsSqliteOpen: return 2113
    case .jsSqliteExec: return 2114
    case .jsSqliteQuery: return 2115
    case .jsSqliteClose: return 2116
    case .subscribeUsersOnlineStatus: return 2229
    case .unsubscribeUsersOnlineStatus: return 2230
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [FuncRequestEventName] = [
    .none,
    .initSdk,
    .login,
    .logout,
    .setAppBackgroundStatus,
    .networkStatusChanged,
    .getLoginStatus,
    .version,
    .sendMessage,
    .uploadLogs,
    .uploadFile,
    .log,
    .updateFcmToken,
    .setAppBadge,
    .eventOnSendMsgProgress,
    .eventOnUploadFileProgress,
    .eventOnUploadLogsProgress,
    .eventOnConnecting,
    .eventOnConnectSuccess,
    .eventOnConnectFailed,
    .eventOnKickedOffline,
    .eventOnUserTokenExpired,
    .eventOnUserTokenInvalid,
    .eventOnSyncServerStart,
    .eventOnSyncServerFinish,
    .eventOnSyncServerFailed,
    .eventOnSyncServerProgress,
    .eventOnNewConversation,
    .eventOnConversationChanged,
    .eventOnTotalUnreadMessageCountChanged,
    .eventOnConversationUserInputStatusChanged,
    .eventOnRecvNewMessage,
    .eventOnRecvC2CreadReceipt,
    .eventOnNewRecvMessageRevoked,
    .eventOnRecvOfflineNewMessage,
    .eventOnMessageDeleted,
    .eventOnRecvOnlineOnlyMessage,
    .eventOnMessageEdited,
    .eventOnFriendApplicationAdded,
    .eventOnFriendApplicationDeleted,
    .eventOnFriendApplicationAccepted,
    .eventOnFriendApplicationRejected,
    .eventOnFriendAdded,
    .eventOnFriendDeleted,
    .eventOnFriendInfoChanged,
    .eventOnBlackAdded,
    .eventOnBlackDeleted,
    .eventOnJoinedGroupAdded,
    .eventOnJoinedGroupDeleted,
    .eventOnGroupMemberAdded,
    .eventOnGroupMemberDeleted,
    .eventOnGroupApplicationAdded,
    .eventOnGroupApplicationDeleted,
    .eventOnGroupInfoChanged,
    .eventOnGroupDismissed,
    .eventOnGroupMemberInfoChanged,
    .eventOnGroupApplicationAccepted,
    .eventOnGroupApplicationRejected,
    .eventOnRecvCustomBusinessMessage,
    .eventOnSelfInfoUpdated,
    .eventOnUserStatusChanged,
    .eventOnUserCommandAdd,
    .eventOnUserCommandDelete,
    .eventOnUserCommandUpdate,
    .createGroup,
    .joinGroup,
    .quitGroup,
    .dismissGroup,
    .changeGroupMute,
    .changeGroupMemberMute,
    .transferGroupOwner,
    .kickGroupMember,
    .setGroupInfo,
    .setGroupMemberInfo,
    .getJoinedGroups,
    .getJoinedGroupsPage,
    .getSpecifiedGroupsInfo,
    .searchGroups,
    .getGroupMemberOwnerAndAdmin,
    .getGroupMembersByJoinTimeFilter,
    .getSpecifiedGroupMembersInfo,
    .getGroupMembers,
    .getGroupRequest,
    .searchGroupMembers,
    .isJoinGroup,
    .getUsersInGroup,
    .inviteUserToGroup,
    .handlerGroupRequest,
    .getSpecifiedFriends,
    .addFriend,
    .getFriendRequests,
    .handlerFriendRequest,
    .checkFriend,
    .deleteFriend,
    .getFriends,
    .getFriendsPage,
    .searchFriends,
    .addBlack,
    .deleteBlack,
    .getBlacks,
    .updateFriends,
    .getAllConversationList,
    .getConversationListSplit,
    .hideConversation,
    .getAtAllTag,
    .getOneConversation,
    .getMultipleConversation,
    .hideAllConversations,
    .setConversationDraft,
    .setConversation,
    .getTotalUnreadMsgCount,
    .getConversationIdbySessionType,
    .findMessageList,
    .getAdvancedHistoryMessageList,
    .getAdvancedHistoryMessageListReverse,
    .revokeMessage,
    .typingStatusUpdate,
    .markConversationMessageAsRead,
    .markAllConversationMessageAsRead,
    .deleteMessageFromLocalStorage,
    .deleteMessage,
    .deleteAllMsgFromLocalAndServer,
    .deleteAllMessageFromLocalStorage,
    .clearConversationAndDeleteAllMsg,
    .deleteConversationAndDeleteAllMsg,
    .insertSingleMessageToLocalStorage,
    .insertGroupMessageToLocalStorage,
    .searchLocalMessages,
    .setMessageLocalEx,
    .searchConversation,
    .createTextMessage,
    .createAdvancedTextMessage,
    .createTextAtMessage,
    .createLocationMessage,
    .createCustomMessage,
    .createQuoteMessage,
    .createAdvancedQuoteMessage,
    .createCardMessage,
    .createImageMessage,
    .createSoundMessage,
    .createVideoMessage,
    .createFileMessage,
    .createMergerMessage,
    .createFaceMessage,
    .createForwardMessage,
    .processUserCommandGetAll,
    .getSelfUserInfo,
    .setSelfInfo,
    .processUserCommandAdd,
    .processUserCommandDelete,
    .processUserCommandUpdate,
    .getUsersInfo,
    .subscribeUsersOnlineStatus,
    .unsubscribeUsersOnlineStatus,
    .jsFileOpen,
    .jsFileRead,
    .jsFileClose,
    .jsSqliteOpen,
    .jsSqliteExec,
    .jsSqliteQuery,
    .jsSqliteClose,
  ]

}

public struct EventOnSendMsgProgressData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var progress: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnUploadFileProgressData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var progress: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnUploadLogsProgressData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var progress: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnConnectingData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnConnectSuccessData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnConnectFailedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var errCode: Int32 = 0

  public var errMsg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnKickedOfflineData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnUserTokenExpiredData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnUserTokenInvalidData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var errMsg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnSyncServerStartData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reinstalled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnSyncServerFinishData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reinstalled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnSyncServerFailedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reinstalled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnSyncServerProgressData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var progress: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnNewConversationData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationList: [IMConversation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnConversationChangedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationList: [IMConversation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnTotalUnreadMessageCountChangedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var totalUnreadCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnConversationUserInputStatusChangedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String = String()

  public var userID: String = String()

  public var platformIds: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnRecvNewMessageData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: IMMessage {
    get {return _message ?? IMMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: IMMessage? = nil
}

public struct MessageReceipt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: String = String()

  public var userID: String = String()

  public var msgIdlist: [String] = []

  public var readTime: Int64 = 0

  public var msgFrom: Int32 = 0

  public var contentType: Int32 = 0

  public var sessionType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnRecvC2CReadReceiptData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var msgReceiptList: [MessageReceipt] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnNewRecvMessageRevokedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var revoked: RevokedTips {
    get {return _revoked ?? RevokedTips()}
    set {_revoked = newValue}
  }
  /// Returns true if `revoked` has been explicitly set.
  public var hasRevoked: Bool {return self._revoked != nil}
  /// Clears the value of `revoked`. Subsequent reads from it will return its default value.
  public mutating func clearRevoked() {self._revoked = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _revoked: RevokedTips? = nil
}

public struct EventOnRecvOfflineNewMessageData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: IMMessage {
    get {return _message ?? IMMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: IMMessage? = nil
}

public struct EventOnMessageDeletedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: IMMessage {
    get {return _message ?? IMMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: IMMessage? = nil
}

public struct EventOnRecvOnlineOnlyMessageData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: IMMessage {
    get {return _message ?? IMMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: IMMessage? = nil
}

public struct EventOnMessageEditedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: IMMessage {
    get {return _message ?? IMMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: IMMessage? = nil
}

/// FriendCallback Data Types
public struct EventOnFriendApplicationAddedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: IMFriendApplication {
    get {return _request ?? IMFriendApplication()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _request: IMFriendApplication? = nil
}

public struct EventOnFriendApplicationDeletedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: IMFriendApplication {
    get {return _request ?? IMFriendApplication()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _request: IMFriendApplication? = nil
}

public struct EventOnFriendApplicationAcceptedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: IMFriendApplication {
    get {return _request ?? IMFriendApplication()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _request: IMFriendApplication? = nil
}

public struct EventOnFriendApplicationRejectedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: IMFriendApplication {
    get {return _request ?? IMFriendApplication()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _request: IMFriendApplication? = nil
}

public struct EventOnFriendAddedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var friend: IMFriend {
    get {return _friend ?? IMFriend()}
    set {_friend = newValue}
  }
  /// Returns true if `friend` has been explicitly set.
  public var hasFriend: Bool {return self._friend != nil}
  /// Clears the value of `friend`. Subsequent reads from it will return its default value.
  public mutating func clearFriend() {self._friend = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _friend: IMFriend? = nil
}

public struct EventOnFriendDeletedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var friend: IMFriend {
    get {return _friend ?? IMFriend()}
    set {_friend = newValue}
  }
  /// Returns true if `friend` has been explicitly set.
  public var hasFriend: Bool {return self._friend != nil}
  /// Clears the value of `friend`. Subsequent reads from it will return its default value.
  public mutating func clearFriend() {self._friend = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _friend: IMFriend? = nil
}

public struct EventOnFriendInfoChangedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var friend: IMFriend {
    get {return _friend ?? IMFriend()}
    set {_friend = newValue}
  }
  /// Returns true if `friend` has been explicitly set.
  public var hasFriend: Bool {return self._friend != nil}
  /// Clears the value of `friend`. Subsequent reads from it will return its default value.
  public mutating func clearFriend() {self._friend = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _friend: IMFriend? = nil
}

public struct EventOnBlackAddedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var black: IMBlack {
    get {return _black ?? IMBlack()}
    set {_black = newValue}
  }
  /// Returns true if `black` has been explicitly set.
  public var hasBlack: Bool {return self._black != nil}
  /// Clears the value of `black`. Subsequent reads from it will return its default value.
  public mutating func clearBlack() {self._black = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _black: IMBlack? = nil
}

public struct EventOnBlackDeletedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var black: IMBlack {
    get {return _black ?? IMBlack()}
    set {_black = newValue}
  }
  /// Returns true if `black` has been explicitly set.
  public var hasBlack: Bool {return self._black != nil}
  /// Clears the value of `black`. Subsequent reads from it will return its default value.
  public mutating func clearBlack() {self._black = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _black: IMBlack? = nil
}

/// GroupCallback Data Types
public struct EventOnJoinedGroupAddedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _group ?? IMGroup()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _group: IMGroup? = nil
}

public struct EventOnJoinedGroupDeletedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _group ?? IMGroup()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _group: IMGroup? = nil
}

public struct EventOnGroupMemberAddedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var member: IMGroupMember {
    get {return _member ?? IMGroupMember()}
    set {_member = newValue}
  }
  /// Returns true if `member` has been explicitly set.
  public var hasMember: Bool {return self._member != nil}
  /// Clears the value of `member`. Subsequent reads from it will return its default value.
  public mutating func clearMember() {self._member = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _member: IMGroupMember? = nil
}

public struct EventOnGroupMemberDeletedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var member: IMGroupMember {
    get {return _member ?? IMGroupMember()}
    set {_member = newValue}
  }
  /// Returns true if `member` has been explicitly set.
  public var hasMember: Bool {return self._member != nil}
  /// Clears the value of `member`. Subsequent reads from it will return its default value.
  public mutating func clearMember() {self._member = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _member: IMGroupMember? = nil
}

public struct EventOnGroupApplicationAddedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: IMGroupApplication {
    get {return _request ?? IMGroupApplication()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _request: IMGroupApplication? = nil
}

public struct EventOnGroupApplicationDeletedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: IMGroupApplication {
    get {return _request ?? IMGroupApplication()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _request: IMGroupApplication? = nil
}

public struct EventOnGroupInfoChangedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _group ?? IMGroup()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _group: IMGroup? = nil
}

public struct EventOnGroupDismissedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var group: IMGroup {
    get {return _group ?? IMGroup()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _group: IMGroup? = nil
}

public struct EventOnGroupMemberInfoChangedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var member: IMGroupMember {
    get {return _member ?? IMGroupMember()}
    set {_member = newValue}
  }
  /// Returns true if `member` has been explicitly set.
  public var hasMember: Bool {return self._member != nil}
  /// Clears the value of `member`. Subsequent reads from it will return its default value.
  public mutating func clearMember() {self._member = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _member: IMGroupMember? = nil
}

public struct EventOnGroupApplicationAcceptedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: IMGroupApplication {
    get {return _request ?? IMGroupApplication()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _request: IMGroupApplication? = nil
}

public struct EventOnGroupApplicationRejectedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: IMGroupApplication {
    get {return _request ?? IMGroupApplication()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _request: IMGroupApplication? = nil
}

/// CustomBusinessCallback Data Type
public struct EventOnRecvCustomBusinessMessageData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var businessMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UserCallback Data Types
public struct EventOnSelfInfoUpdatedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: IMUser {
    get {return _user ?? IMUser()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: IMUser? = nil
}

public struct EventOnUserStatusChangedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var platformIds: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventOnUserCommandAddData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: CommandInfo {
    get {return _command ?? CommandInfo()}
    set {_command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  public var hasCommand: Bool {return self._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  public mutating func clearCommand() {self._command = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _command: CommandInfo? = nil
}

public struct EventOnUserCommandDeleteData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: CommandInfo {
    get {return _command ?? CommandInfo()}
    set {_command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  public var hasCommand: Bool {return self._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  public mutating func clearCommand() {self._command = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _command: CommandInfo? = nil
}

public struct EventOnUserCommandUpdateData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: CommandInfo {
    get {return _command ?? CommandInfo()}
    set {_command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  public var hasCommand: Bool {return self._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  public mutating func clearCommand() {self._command = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _command: CommandInfo? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "openim.event"

extension FuncRequestEventName: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "InitSDK"),
    2: .same(proto: "Login"),
    3: .same(proto: "Logout"),
    4: .same(proto: "SendMessage"),
    5: .same(proto: "UploadLogs"),
    6: .same(proto: "UploadFile"),
    7: .same(proto: "Log"),
    10: .same(proto: "UpdateFcmToken"),
    11: .same(proto: "SetAppBadge"),
    12: .same(proto: "EventOnSendMsgProgress"),
    13: .same(proto: "EventOnUploadFileProgress"),
    14: .same(proto: "EventOnUploadLogsProgress"),
    15: .same(proto: "EventOnConnecting"),
    16: .same(proto: "EventOnConnectSuccess"),
    17: .same(proto: "EventOnConnectFailed"),
    18: .same(proto: "EventOnKickedOffline"),
    19: .same(proto: "EventOnUserTokenExpired"),
    20: .same(proto: "EventOnUserTokenInvalid"),
    21: .same(proto: "EventOnSyncServerStart"),
    22: .same(proto: "EventOnSyncServerFinish"),
    23: .same(proto: "EventOnSyncServerFailed"),
    24: .same(proto: "EventOnSyncServerProgress"),
    25: .same(proto: "EventOnNewConversation"),
    26: .same(proto: "EventOnConversationChanged"),
    27: .same(proto: "EventOnTotalUnreadMessageCountChanged"),
    28: .same(proto: "EventOnConversationUserInputStatusChanged"),
    29: .same(proto: "EventOnRecvNewMessage"),
    30: .same(proto: "EventOnRecvC2CReadReceipt"),
    31: .same(proto: "EventOnNewRecvMessageRevoked"),
    32: .same(proto: "EventOnRecvOfflineNewMessage"),
    33: .same(proto: "EventOnMessageDeleted"),
    34: .same(proto: "EventOnRecvOnlineOnlyMessage"),
    35: .same(proto: "EventOnMessageEdited"),
    36: .same(proto: "EventOnFriendApplicationAdded"),
    37: .same(proto: "EventOnFriendApplicationDeleted"),
    38: .same(proto: "EventOnFriendApplicationAccepted"),
    39: .same(proto: "EventOnFriendApplicationRejected"),
    40: .same(proto: "EventOnFriendAdded"),
    41: .same(proto: "EventOnFriendDeleted"),
    42: .same(proto: "EventOnFriendInfoChanged"),
    43: .same(proto: "EventOnBlackAdded"),
    44: .same(proto: "EventOnBlackDeleted"),
    45: .same(proto: "EventOnJoinedGroupAdded"),
    46: .same(proto: "EventOnJoinedGroupDeleted"),
    47: .same(proto: "EventOnGroupMemberAdded"),
    48: .same(proto: "EventOnGroupMemberDeleted"),
    49: .same(proto: "EventOnGroupApplicationAdded"),
    50: .same(proto: "EventOnGroupApplicationDeleted"),
    51: .same(proto: "EventOnGroupInfoChanged"),
    52: .same(proto: "EventOnGroupDismissed"),
    53: .same(proto: "EventOnGroupMemberInfoChanged"),
    54: .same(proto: "EventOnGroupApplicationAccepted"),
    55: .same(proto: "EventOnGroupApplicationRejected"),
    56: .same(proto: "EventOnRecvCustomBusinessMessage"),
    57: .same(proto: "EventOnSelfInfoUpdated"),
    58: .same(proto: "EventOnUserStatusChanged"),
    59: .same(proto: "EventOnUserCommandAdd"),
    60: .same(proto: "EventOnUserCommandDelete"),
    61: .same(proto: "EventOnUserCommandUpdate"),
    107: .same(proto: "SetAppBackgroundStatus"),
    108: .same(proto: "NetworkStatusChanged"),
    109: .same(proto: "GetLoginStatus"),
    110: .same(proto: "Version"),
    1000: .same(proto: "CreateGroup"),
    1001: .same(proto: "JoinGroup"),
    1002: .same(proto: "QuitGroup"),
    1003: .same(proto: "DismissGroup"),
    1004: .same(proto: "ChangeGroupMute"),
    1005: .same(proto: "ChangeGroupMemberMute"),
    1006: .same(proto: "TransferGroupOwner"),
    1007: .same(proto: "KickGroupMember"),
    1008: .same(proto: "SetGroupInfo"),
    1009: .same(proto: "SetGroupMemberInfo"),
    1010: .same(proto: "GetJoinedGroups"),
    1011: .same(proto: "GetJoinedGroupsPage"),
    1012: .same(proto: "GetSpecifiedGroupsInfo"),
    1013: .same(proto: "SearchGroups"),
    1014: .same(proto: "GetGroupMemberOwnerAndAdmin"),
    1015: .same(proto: "GetGroupMembersByJoinTimeFilter"),
    1016: .same(proto: "GetSpecifiedGroupMembersInfo"),
    1017: .same(proto: "GetGroupMembers"),
    1018: .same(proto: "GetGroupRequest"),
    1019: .same(proto: "SearchGroupMembers"),
    1020: .same(proto: "IsJoinGroup"),
    1021: .same(proto: "GetUsersInGroup"),
    1022: .same(proto: "InviteUserToGroup"),
    1023: .same(proto: "HandlerGroupRequest"),
    1100: .same(proto: "GetSpecifiedFriends"),
    1101: .same(proto: "AddFriend"),
    1102: .same(proto: "GetFriendRequests"),
    1103: .same(proto: "HandlerFriendRequest"),
    1104: .same(proto: "CheckFriend"),
    1105: .same(proto: "DeleteFriend"),
    1106: .same(proto: "GetFriends"),
    1107: .same(proto: "GetFriendsPage"),
    1108: .same(proto: "SearchFriends"),
    1109: .same(proto: "AddBlack"),
    1110: .same(proto: "DeleteBlack"),
    1111: .same(proto: "GetBlacks"),
    1112: .same(proto: "UpdateFriends"),
    2000: .same(proto: "GetAllConversationList"),
    2001: .same(proto: "GetConversationListSplit"),
    2002: .same(proto: "HideConversation"),
    2003: .same(proto: "GetAtAllTag"),
    2004: .same(proto: "GetOneConversation"),
    2005: .same(proto: "GetMultipleConversation"),
    2006: .same(proto: "HideAllConversations"),
    2007: .same(proto: "SetConversationDraft"),
    2008: .same(proto: "SetConversation"),
    2009: .same(proto: "GetTotalUnreadMsgCount"),
    2010: .same(proto: "GetConversationIDBySessionType"),
    2011: .same(proto: "FindMessageList"),
    2012: .same(proto: "GetAdvancedHistoryMessageList"),
    2013: .same(proto: "GetAdvancedHistoryMessageListReverse"),
    2014: .same(proto: "RevokeMessage"),
    2015: .same(proto: "TypingStatusUpdate"),
    2016: .same(proto: "MarkConversationMessageAsRead"),
    2017: .same(proto: "MarkAllConversationMessageAsRead"),
    2018: .same(proto: "DeleteMessageFromLocalStorage"),
    2019: .same(proto: "DeleteMessage"),
    2020: .same(proto: "DeleteAllMsgFromLocalAndServer"),
    2021: .same(proto: "DeleteAllMessageFromLocalStorage"),
    2022: .same(proto: "ClearConversationAndDeleteAllMsg"),
    2023: .same(proto: "DeleteConversationAndDeleteAllMsg"),
    2024: .same(proto: "InsertSingleMessageToLocalStorage"),
    2025: .same(proto: "InsertGroupMessageToLocalStorage"),
    2026: .same(proto: "SearchLocalMessages"),
    2027: .same(proto: "SetMessageLocalEx"),
    2028: .same(proto: "SearchConversation"),
    2029: .same(proto: "CreateTextMessage"),
    2030: .same(proto: "CreateAdvancedTextMessage"),
    2031: .same(proto: "CreateTextAtMessage"),
    2032: .same(proto: "CreateLocationMessage"),
    2033: .same(proto: "CreateCustomMessage"),
    2034: .same(proto: "CreateQuoteMessage"),
    2035: .same(proto: "CreateAdvancedQuoteMessage"),
    2036: .same(proto: "CreateCardMessage"),
    2037: .same(proto: "CreateImageMessage"),
    2038: .same(proto: "CreateSoundMessage"),
    2039: .same(proto: "CreateVideoMessage"),
    2040: .same(proto: "CreateFileMessage"),
    2041: .same(proto: "CreateMergerMessage"),
    2042: .same(proto: "CreateFaceMessage"),
    2043: .same(proto: "CreateForwardMessage"),
    2100: .same(proto: "ProcessUserCommandGetAll"),
    2101: .same(proto: "GetSelfUserInfo"),
    2102: .same(proto: "SetSelfInfo"),
    2103: .same(proto: "ProcessUserCommandAdd"),
    2104: .same(proto: "ProcessUserCommandDelete"),
    2105: .same(proto: "ProcessUserCommandUpdate"),
    2106: .same(proto: "GetUsersInfo"),
    2110: .same(proto: "JsFileOpen"),
    2111: .same(proto: "JsFileRead"),
    2112: .same(proto: "JsFileClose"),
    2113: .same(proto: "JsSqliteOpen"),
    2114: .same(proto: "JsSqliteExec"),
    2115: .same(proto: "JsSqliteQuery"),
    2116: .same(proto: "JsSqliteClose"),
    2229: .same(proto: "SubscribeUsersOnlineStatus"),
    2230: .same(proto: "UnsubscribeUsersOnlineStatus"),
  ]
}

extension EventOnSendMsgProgressData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnSendMsgProgressData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.progress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.progress != 0 {
      try visitor.visitSingularInt32Field(value: self.progress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnSendMsgProgressData, rhs: EventOnSendMsgProgressData) -> Bool {
    if lhs.progress != rhs.progress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnUploadFileProgressData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnUploadFileProgressData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.progress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.progress != 0 {
      try visitor.visitSingularInt32Field(value: self.progress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnUploadFileProgressData, rhs: EventOnUploadFileProgressData) -> Bool {
    if lhs.progress != rhs.progress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnUploadLogsProgressData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnUploadLogsProgressData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.progress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.progress != 0 {
      try visitor.visitSingularInt32Field(value: self.progress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnUploadLogsProgressData, rhs: EventOnUploadLogsProgressData) -> Bool {
    if lhs.progress != rhs.progress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnConnectingData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnConnectingData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnConnectingData, rhs: EventOnConnectingData) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnConnectSuccessData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnConnectSuccessData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnConnectSuccessData, rhs: EventOnConnectSuccessData) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnConnectFailedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnConnectFailedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errCode"),
    2: .same(proto: "errMsg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.errCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errMsg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errCode != 0 {
      try visitor.visitSingularInt32Field(value: self.errCode, fieldNumber: 1)
    }
    if !self.errMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errMsg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnConnectFailedData, rhs: EventOnConnectFailedData) -> Bool {
    if lhs.errCode != rhs.errCode {return false}
    if lhs.errMsg != rhs.errMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnKickedOfflineData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnKickedOfflineData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnKickedOfflineData, rhs: EventOnKickedOfflineData) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnUserTokenExpiredData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnUserTokenExpiredData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnUserTokenExpiredData, rhs: EventOnUserTokenExpiredData) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnUserTokenInvalidData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnUserTokenInvalidData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errMsg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errMsg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errMsg, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnUserTokenInvalidData, rhs: EventOnUserTokenInvalidData) -> Bool {
    if lhs.errMsg != rhs.errMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnSyncServerStartData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnSyncServerStartData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reinstalled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.reinstalled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reinstalled != false {
      try visitor.visitSingularBoolField(value: self.reinstalled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnSyncServerStartData, rhs: EventOnSyncServerStartData) -> Bool {
    if lhs.reinstalled != rhs.reinstalled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnSyncServerFinishData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnSyncServerFinishData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reinstalled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.reinstalled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reinstalled != false {
      try visitor.visitSingularBoolField(value: self.reinstalled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnSyncServerFinishData, rhs: EventOnSyncServerFinishData) -> Bool {
    if lhs.reinstalled != rhs.reinstalled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnSyncServerFailedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnSyncServerFailedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reinstalled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.reinstalled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reinstalled != false {
      try visitor.visitSingularBoolField(value: self.reinstalled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnSyncServerFailedData, rhs: EventOnSyncServerFailedData) -> Bool {
    if lhs.reinstalled != rhs.reinstalled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnSyncServerProgressData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnSyncServerProgressData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.progress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.progress != 0 {
      try visitor.visitSingularInt32Field(value: self.progress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnSyncServerProgressData, rhs: EventOnSyncServerProgressData) -> Bool {
    if lhs.progress != rhs.progress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnNewConversationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnNewConversationData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversationList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.conversationList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conversationList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnNewConversationData, rhs: EventOnNewConversationData) -> Bool {
    if lhs.conversationList != rhs.conversationList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnConversationChangedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnConversationChangedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversationList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.conversationList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conversationList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnConversationChangedData, rhs: EventOnConversationChangedData) -> Bool {
    if lhs.conversationList != rhs.conversationList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnTotalUnreadMessageCountChangedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnTotalUnreadMessageCountChangedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "totalUnreadCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.totalUnreadCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalUnreadCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalUnreadCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnTotalUnreadMessageCountChangedData, rhs: EventOnTotalUnreadMessageCountChangedData) -> Bool {
    if lhs.totalUnreadCount != rhs.totalUnreadCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnConversationUserInputStatusChangedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnConversationUserInputStatusChangedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversationID"),
    2: .same(proto: "userID"),
    3: .same(proto: "platformIDs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.platformIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.platformIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.platformIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnConversationUserInputStatusChangedData, rhs: EventOnConversationUserInputStatusChangedData) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.platformIds != rhs.platformIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnRecvNewMessageData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnRecvNewMessageData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnRecvNewMessageData, rhs: EventOnRecvNewMessageData) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupID"),
    2: .same(proto: "userID"),
    3: .same(proto: "msgIDList"),
    4: .same(proto: "readTime"),
    5: .same(proto: "msgFrom"),
    6: .same(proto: "contentType"),
    7: .same(proto: "sessionType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.msgIdlist) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.readTime) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.msgFrom) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.contentType) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.sessionType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.msgIdlist.isEmpty {
      try visitor.visitRepeatedStringField(value: self.msgIdlist, fieldNumber: 3)
    }
    if self.readTime != 0 {
      try visitor.visitSingularInt64Field(value: self.readTime, fieldNumber: 4)
    }
    if self.msgFrom != 0 {
      try visitor.visitSingularInt32Field(value: self.msgFrom, fieldNumber: 5)
    }
    if self.contentType != 0 {
      try visitor.visitSingularInt32Field(value: self.contentType, fieldNumber: 6)
    }
    if self.sessionType != 0 {
      try visitor.visitSingularInt32Field(value: self.sessionType, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageReceipt, rhs: MessageReceipt) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.msgIdlist != rhs.msgIdlist {return false}
    if lhs.readTime != rhs.readTime {return false}
    if lhs.msgFrom != rhs.msgFrom {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.sessionType != rhs.sessionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnRecvC2CReadReceiptData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnRecvC2CReadReceiptData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msgReceiptList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.msgReceiptList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgReceiptList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.msgReceiptList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnRecvC2CReadReceiptData, rhs: EventOnRecvC2CReadReceiptData) -> Bool {
    if lhs.msgReceiptList != rhs.msgReceiptList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnNewRecvMessageRevokedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnNewRecvMessageRevokedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "revoked"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._revoked) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._revoked {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnNewRecvMessageRevokedData, rhs: EventOnNewRecvMessageRevokedData) -> Bool {
    if lhs._revoked != rhs._revoked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnRecvOfflineNewMessageData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnRecvOfflineNewMessageData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnRecvOfflineNewMessageData, rhs: EventOnRecvOfflineNewMessageData) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnMessageDeletedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnMessageDeletedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnMessageDeletedData, rhs: EventOnMessageDeletedData) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnRecvOnlineOnlyMessageData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnRecvOnlineOnlyMessageData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnRecvOnlineOnlyMessageData, rhs: EventOnRecvOnlineOnlyMessageData) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnMessageEditedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnMessageEditedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnMessageEditedData, rhs: EventOnMessageEditedData) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnFriendApplicationAddedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnFriendApplicationAddedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnFriendApplicationAddedData, rhs: EventOnFriendApplicationAddedData) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnFriendApplicationDeletedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnFriendApplicationDeletedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnFriendApplicationDeletedData, rhs: EventOnFriendApplicationDeletedData) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnFriendApplicationAcceptedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnFriendApplicationAcceptedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnFriendApplicationAcceptedData, rhs: EventOnFriendApplicationAcceptedData) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnFriendApplicationRejectedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnFriendApplicationRejectedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnFriendApplicationRejectedData, rhs: EventOnFriendApplicationRejectedData) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnFriendAddedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnFriendAddedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "friend"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._friend) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._friend {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnFriendAddedData, rhs: EventOnFriendAddedData) -> Bool {
    if lhs._friend != rhs._friend {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnFriendDeletedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnFriendDeletedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "friend"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._friend) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._friend {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnFriendDeletedData, rhs: EventOnFriendDeletedData) -> Bool {
    if lhs._friend != rhs._friend {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnFriendInfoChangedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnFriendInfoChangedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "friend"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._friend) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._friend {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnFriendInfoChangedData, rhs: EventOnFriendInfoChangedData) -> Bool {
    if lhs._friend != rhs._friend {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnBlackAddedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnBlackAddedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "black"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._black) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._black {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnBlackAddedData, rhs: EventOnBlackAddedData) -> Bool {
    if lhs._black != rhs._black {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnBlackDeletedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnBlackDeletedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "black"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._black) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._black {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnBlackDeletedData, rhs: EventOnBlackDeletedData) -> Bool {
    if lhs._black != rhs._black {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnJoinedGroupAddedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnJoinedGroupAddedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnJoinedGroupAddedData, rhs: EventOnJoinedGroupAddedData) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnJoinedGroupDeletedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnJoinedGroupDeletedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnJoinedGroupDeletedData, rhs: EventOnJoinedGroupDeletedData) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnGroupMemberAddedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnGroupMemberAddedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnGroupMemberAddedData, rhs: EventOnGroupMemberAddedData) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnGroupMemberDeletedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnGroupMemberDeletedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnGroupMemberDeletedData, rhs: EventOnGroupMemberDeletedData) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnGroupApplicationAddedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnGroupApplicationAddedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnGroupApplicationAddedData, rhs: EventOnGroupApplicationAddedData) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnGroupApplicationDeletedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnGroupApplicationDeletedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnGroupApplicationDeletedData, rhs: EventOnGroupApplicationDeletedData) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnGroupInfoChangedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnGroupInfoChangedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnGroupInfoChangedData, rhs: EventOnGroupInfoChangedData) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnGroupDismissedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnGroupDismissedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnGroupDismissedData, rhs: EventOnGroupDismissedData) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnGroupMemberInfoChangedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnGroupMemberInfoChangedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnGroupMemberInfoChangedData, rhs: EventOnGroupMemberInfoChangedData) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnGroupApplicationAcceptedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnGroupApplicationAcceptedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnGroupApplicationAcceptedData, rhs: EventOnGroupApplicationAcceptedData) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnGroupApplicationRejectedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnGroupApplicationRejectedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnGroupApplicationRejectedData, rhs: EventOnGroupApplicationRejectedData) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnRecvCustomBusinessMessageData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnRecvCustomBusinessMessageData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "businessMessage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.businessMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.businessMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.businessMessage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnRecvCustomBusinessMessageData, rhs: EventOnRecvCustomBusinessMessageData) -> Bool {
    if lhs.businessMessage != rhs.businessMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnSelfInfoUpdatedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnSelfInfoUpdatedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnSelfInfoUpdatedData, rhs: EventOnSelfInfoUpdatedData) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnUserStatusChangedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnUserStatusChangedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userID"),
    2: .same(proto: "platformIDs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.platformIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.platformIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.platformIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnUserStatusChangedData, rhs: EventOnUserStatusChangedData) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.platformIds != rhs.platformIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnUserCommandAddData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnUserCommandAddData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._command) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._command {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnUserCommandAddData, rhs: EventOnUserCommandAddData) -> Bool {
    if lhs._command != rhs._command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnUserCommandDeleteData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnUserCommandDeleteData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._command) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._command {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnUserCommandDeleteData, rhs: EventOnUserCommandDeleteData) -> Bool {
    if lhs._command != rhs._command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventOnUserCommandUpdateData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventOnUserCommandUpdateData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._command) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._command {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventOnUserCommandUpdateData, rhs: EventOnUserCommandUpdateData) -> Bool {
    if lhs._command != rhs._command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
